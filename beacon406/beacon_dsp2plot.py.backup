
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
beacon_dsp2plot.py — UI-клиент к beacon_dsp_service.py (ZeroMQ)
Сохраняет внешний вид и UX «-plot», но все DSP берёт из сервиса.
- Подписка на PUB: status / pulse / psk
- Команды в REP: start/stop/set_params/get_status/get_sdr_config/set_sdr_config/save_sigmf
- Поддержка backend-кнопок (Auto/RTL/HackRF/Airspy/SDRplay/RSA/File)
- В режиме File: BB_SHIFT отключён на стороне сервиса (инвариант)
"""
import os
import sys
import json
import time
import threading
import queue
from dataclasses import dataclass
from typing import Optional, Callable, Dict, Any, Tuple
from pathlib import Path

# UI
import numpy as np
import matplotlib
try:
    matplotlib.use("TkAgg")
except Exception:
    pass
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
from tkinter import filedialog
import tkinter as tk
import signal

# ZMQ (optional soft dependency for dev boxes)
try:
    import zmq
except Exception:
    zmq = None

# -------------------- Параметры подключения к сервису --------------------
PUB_ADDR_DEFAULT = "tcp://127.0.0.1:8781"
REP_ADDR_DEFAULT = "tcp://127.0.0.1:8782"

# -------------------- Вспомогательные --------------------
EPS = 1e-20

def db10(x: np.ndarray) -> np.ndarray:
    return 10.0 * np.log10(np.maximum(x, EPS))

# -------------------- DspServiceClient --------------------
class DspServiceClient:
    """Тонкая обёртка над ZeroMQ PUB/REP beacon_dsp_service.py."""
    def __init__(self, pub_addr: str = PUB_ADDR_DEFAULT, rep_addr: str = REP_ADDR_DEFAULT):
        if zmq is None:
            raise RuntimeError("pyzmq не установлен. Установите пакет 'pyzmq'")
        self.ctx = zmq.Context.instance()
        self.pub_addr = pub_addr
        self.rep_addr = rep_addr
        self._stop = False
        self._req_lock = threading.Lock()
        self._req_socket_broken = False

        # SUB
        self.sub = self.ctx.socket(zmq.SUB)
        self.sub.connect(self.pub_addr)
        self.sub.setsockopt_string(zmq.SUBSCRIBE, "")  # все события

        # REQ (will be created/recreated by _ensure_req_socket)
        self.req = None
        self._ensure_req_socket()

        self._sub_thread: Optional[threading.Thread] = None
        self._cb: Optional[Callable[[Dict[str, Any]], None]] = None


    def _ensure_req_socket(self):
        """Ensure REQ socket is connected and ready. Recreate if needed."""
        if self.req is not None and not self._req_socket_broken:
            return

        try:
            if self.req is not None:
                self.req.close(0)
        except Exception:
            pass

        self.req = self.ctx.socket(zmq.REQ)
        # Set reasonable timeouts for stable operation
        # Increased timeout for file operations which may take longer
        try:
            self.req.setsockopt(zmq.RCVTIMEO, 10000)  # 10 second receive timeout for file operations
            self.req.setsockopt(zmq.SNDTIMEO, 5000)   # 5 second send timeout
            self.req.setsockopt(zmq.LINGER, 0)        # Don't wait on close
        except Exception:
            pass

        self.req.connect(self.rep_addr)
        self._req_socket_broken = False

    def quick_status_check(self):
        """Quick status check with short timeout to test if service is responsive."""
        temp_req = self.ctx.socket(zmq.REQ)
        try:
            temp_req.setsockopt(zmq.RCVTIMEO, 1000)  # 1 second timeout
            temp_req.setsockopt(zmq.SNDTIMEO, 1000)  # 1 second timeout
            temp_req.setsockopt(zmq.LINGER, 0)
            temp_req.connect(self.rep_addr)

            import json
            req = {"cmd": "get_status"}
            temp_req.send_string(json.dumps(req))
            resp_str = temp_req.recv_string()
            rep = json.loads(resp_str)
            return rep if isinstance(rep, dict) else None
        except Exception:
            return None
        finally:
            temp_req.close(0)

    # ---- stream ----
    def subscribe_events(self, callback: Callable[[Dict[str, Any]], None]):
        self._cb = callback
        if self._sub_thread and self._sub_thread.is_alive():
            return
        self._stop = False
        self._sub_thread = threading.Thread(target=self._sub_loop, daemon=True)
        self._sub_thread.start()

    def _sub_loop(self):
        poller = zmq.Poller()
        poller.register(self.sub, zmq.POLLIN)
        while not self._stop:
            socks = dict(poller.poll(200))
            if self.sub in socks and socks[self.sub] == zmq.POLLIN:
                try:
                    line = self.sub.recv_string(flags=zmq.NOBLOCK)
                    obj = json.loads(line)
                    if self._cb:
                        self._cb(obj)
                except Exception:
                    pass

    # ---- commands (REQ/REP) ----
    def _cmd(self, name: str, **kwargs) -> Dict[str, Any]:
        msg = {"cmd": name, **kwargs}

        # Try up to 5 times for better reliability during backend switches
        max_retries = 5

        for attempt in range(max_retries):
            with self._req_lock:
                try:
                    self._ensure_req_socket()

                    # Use blocking calls - the socket timeout options will handle timeouts
                    self.req.send_json(msg)
                    rep = self.req.recv_json()

                    # Success - reset failure flag
                    self._req_socket_broken = False
                    return rep if isinstance(rep, dict) else {"ok": False, "error": "bad reply"}

                except zmq.error.Again:
                    # Timeout - mark socket as potentially broken
                    self._req_socket_broken = True
                    if attempt < max_retries - 1:
                        time.sleep(0.2 * (attempt + 1))  # Progressive backoff
                        continue
                    else:
                        return {"ok": False, "error": "Timeout waiting for DSP service"}

                except Exception as e:
                    # Other error - mark socket as broken and retry
                    self._req_socket_broken = True
                    if attempt < max_retries - 1:
                        time.sleep(0.2 * (attempt + 1))  # Progressive backoff
                        continue
                    else:
                        return {"ok": False, "error": f"Communication error: {e}"}

        # This should never be reached due to the else clauses above, but just in case
        return {"ok": False, "error": "Max retries exceeded"}

    def start_acquire(self) -> Dict[str, Any]: return self._cmd("start_acquire")
    def stop_acquire(self) -> Dict[str, Any]: return self._cmd("stop_acquire")
    def get_status(self) -> Dict[str, Any]: return self._cmd("get_status")
    def get_sdr_config(self) -> Dict[str, Any]: return self._cmd("get_sdr_config")
    def set_sdr_config(self, **cfg) -> Dict[str, Any]:
        # Send config wrapped in 'config' field for DSP service compatibility
        return self._cmd("set_sdr_config", config=cfg)
    def set_params(self, **params) -> Dict[str, Any]: return self._cmd("set_params", **params)
    def save_sigmf(self) -> Dict[str, Any]: return self._cmd("save_sigmf")
    # file ops (если реализованы в сервисе)
    def file_load(self, path: str, start_s: float = 0.0, loop: bool = False) -> Dict[str, Any]:
        return self._cmd("file_load", path=path, start_s=float(start_s), loop=bool(loop))
    def file_seek(self, pos_s: float) -> Dict[str, Any]: return self._cmd("file_seek", pos_s=float(pos_s))
    def file_play(self, rate: float = 1.0) -> Dict[str, Any]: return self._cmd("file_play", rate=float(rate))
    def file_pause(self) -> Dict[str, Any]: return self._cmd("file_pause")
    def file_get_info(self) -> Dict[str, Any]: return self._cmd("file_get_info")

    def close(self):
        self._stop = True
        try:
            if self._sub_thread:
                self._sub_thread.join(timeout=0.3)
        except Exception:
            pass
        with self._req_lock:
            try:
                if self.req: self.req.close(0)
            except Exception: pass
        try: self.sub.close(0)
        except Exception: pass

# -------------------- UI (2 окна как в -plot) --------------------
class Dsp2PlotUI:
    def __init__(self, pub_addr: str, rep_addr: str):
        # Состояние для графиков
        self.last_status: Dict[str, Any] = {}
        self.last_pulse: Dict[str, Any] = {}
        self.last_psk: Dict[str, Any] = {}
        self.last_msg_hex: Optional[str] = None
        self.sample_rate: float = 1_000_000.0

        # Очередь событий из SUB-потока
        self.ev_q: "queue.Queue[Dict[str, Any]]" = queue.Queue(maxsize=128)

        # Клиент сервиса
        self.client = DspServiceClient(pub_addr=pub_addr, rep_addr=rep_addr)
        self._svc_proc = None
        self.client.subscribe_events(self._on_event)
        # первичный статус
        try:
            st = self.client.get_status()
            if isinstance(st, dict): self.last_status = st
            self.sample_rate = float(st.get("fs", self.sample_rate))
        except Exception:
            pass

        # ----- Figure 1: Sliding RMS (как раньше) -----
        self.fig1, self.ax_lvl = plt.subplots(num="Sliding RMS — realtime", figsize=(9, 2.5))
        self.fig1.subplots_adjust(bottom=0.35, top=0.85)

        (self.ln_lvl,) = self.ax_lvl.plot([], [], lw=1.2)
        self.ax_lvl.set_xlabel("Время, с")
        self.ax_lvl.set_ylabel("RMS, dBm")
        self.ax_lvl.grid(True, alpha=0.3)

        # Кнопки backend
        buttons = [
            ("Auto", "auto", 0.02),
            ("RTL", "soapy_rtl", 0.11),
            ("HackRF", "soapy_hackrf", 0.20),
            ("Airspy", "soapy_airspy", 0.29),
            ("SDRPlay", "soapy_sdrplay", 0.38),
            ("RSA306", "rsa306", 0.47),
            ("File", "file", 0.56),
        ]
        self.backend_buttons = {}
        for label, backend, left in buttons:
            ax = self.fig1.add_axes([left, 0.01, 0.08, 0.06])
            btn = Button(ax, label)
            btn.on_clicked(lambda _evt, b=backend: self._on_backend_select(b))
            self.backend_buttons[backend] = btn

        ax_button_file = self.fig1.add_axes([0.73, 0.01, 0.12, 0.06])
        self.btn_file = Button(ax_button_file, "Открыть")
        self.btn_file.on_clicked(self._on_file_select)

        ax_button_exit = self.fig1.add_axes([0.86, 0.01, 0.12, 0.06])
        self.btn_exit = Button(ax_button_exit, "Выход")
        self.btn_exit.on_clicked(self._on_exit)

        # ----- Figure 2: Pulse + Phase + FM -----
        self.fig2, (self.ax_pulse, self.ax_phase, self.ax_fm) = plt.subplots(
            3, 1, figsize=(14, 8.6), height_ratios=[1, 1, 1]
        )
        (self.ln_pulse,) = self.ax_pulse.plot([], [], lw=1.4)
        self.ax_pulse.set_ylabel("RMS, dBm")
        self.ax_pulse.grid(True, alpha=0.3)
        self.ax_pulse.set_xlabel("Время, мс (RMS окно)")

        (self.ln_phase,) = self.ax_phase.plot([], [], lw=1.4)
        self.ax_phase.set_ylabel("Фаза, rad")
        self.ax_phase.grid(True, alpha=0.3)
        self.ax_phase.set_ylim(-1.5, +1.5)

        (self.ln_fm,) = self.ax_fm.plot([], [], lw=1.4)
        self.ax_fm.set_xlabel("Время, мс (0 = старт импульса)")
        self.ax_fm.set_ylabel("FM, Hz")
        self.ax_fm.grid(True, alpha=0.3)

        self.fig2.subplots_adjust(hspace=0.5, top=0.92, bottom=0.15)
        self.fig2.suptitle("Импульс: RMS + Фаза (±1.5 rad) + FM(Hz)")

        # Нижние кнопки
        ax_button_spec = self.fig2.add_axes([0.54, 0.01, 0.15, 0.06])
        self.btn_spec = Button(ax_button_spec, "Спектр")
        self.btn_spec.on_clicked(self._on_show_spectrum)

        ax_button_stat = self.fig2.add_axes([0.22, 0.01, 0.15, 0.06])
        self.btn_stat = Button(ax_button_stat, "Статус SDR")
        self.btn_stat.on_clicked(self._on_show_sdr_status)

        ax_button_params = self.fig2.add_axes([0.38, 0.01, 0.15, 0.06])
        self.btn_params = Button(ax_button_params, "Параметры")
        self.btn_params.on_clicked(self._on_show_params)

        ax_button_save = self.fig2.add_axes([0.70, 0.01, 0.15, 0.06])
        self.btn_save = Button(ax_button_save, "Save SigMF")
        self.btn_save.on_clicked(self._on_save_sigmf)

        ax_button_stop = self.fig2.add_axes([0.86, 0.01, 0.12, 0.06])
        self.btn_stop = Button(ax_button_stop, "Стоп")
        self.btn_stop.on_clicked(self._on_toggle_updates)

        ax_button_msg = self.fig2.add_axes([0.06, 0.01, 0.15, 0.06])
        self.btn_msg = Button(ax_button_msg, "Сообщение")
        self.btn_msg.on_clicked(self._on_show_message)

        # Анимация/таймер обновления из очереди событий
        self._updates_enabled = True
        self._lvl_x: np.ndarray = np.array([], dtype=np.float64)
        self._lvl_y: np.ndarray = np.array([], dtype=np.float64)
        self._timer = self.fig1.canvas.new_timer(interval=200)
        self._timer.add_callback(self._drain_events)
        self._timer.start()

        # Обработчики закрытия окон и горячие клавиши
        try:
            self.fig1.canvas.mpl_connect('close_event', self._on_close)
            self.fig2.canvas.mpl_connect('close_event', self._on_close)
            self.fig1.canvas.mpl_connect('key_press_event', self._on_key)
            self.fig2.canvas.mpl_connect('key_press_event', self._on_key)
        except Exception:
            pass


    # ---------- Event plumbing ----------
    def _on_event(self, obj: Dict[str, Any]):
        try:
            self.ev_q.put_nowait(obj)
        except queue.Full:
            pass

    def _drain_events(self):
        drained = 0
        while not self.ev_q.empty() and drained < 64:
            drained += 1
            try:
                obj = self.ev_q.get_nowait()
            except Exception:
                break
            typ = obj.get("type")
            if typ == "status":
                self.last_status = obj
                fs = float(obj.get("fs", self.sample_rate))
                if fs > 0: self.sample_rate = fs
                lvl_dbm = obj.get("last_rms_dbm", None)
                t_s = obj.get("t_s", None)
                if lvl_dbm is not None and t_s is not None:
                    self._lvl_x = np.array(t_s, dtype=np.float64)
                    self._lvl_y = np.array(lvl_dbm, dtype=np.float64)
                    self.ln_lvl.set_data(self._lvl_x, self._lvl_y)
                    if self._lvl_x.size:
                        self.ax_lvl.set_xlim(self._lvl_x[0], self._lvl_x[-1])
                        ymin, ymax = np.nanmin(self._lvl_y), np.nanmax(self._lvl_y)
                        if np.isfinite(ymin) and np.isfinite(ymax) and ymin < ymax:
                            self.ax_lvl.set_ylim(ymin - 2, ymax + 2)
                    self.fig1.canvas.draw_idle()

            elif typ == "pulse":
                self.last_pulse = obj
                if not self._updates_enabled:
                    continue
                px = np.array(obj.get("phase_xs_ms", []), dtype=np.float64)
                py = np.array(obj.get("phase_ys_rad", []), dtype=np.float64)
                fx = np.array(obj.get("fr_xs_ms", []), dtype=np.float64)
                fy = np.array(obj.get("fr_ys_hz", []), dtype=np.float64)
                rms = np.array(obj.get("rms_ms_dbm", []), dtype=np.float64)

                if rms.size and px.size == rms.size:
                    self.ln_pulse.set_data(px, rms)
                    self.ax_pulse.set_xlim(px.min(), px.max())
                    ymin, ymax = np.nanmin(rms), np.nanmax(rms)
                    if np.isfinite(ymin) and np.isfinite(ymax) and ymin < ymax:
                        self.ax_pulse.set_ylim(ymin - 2, ymax + 2)

                if px.size and py.size and px.size == py.size:
                    if px.size > 0 and py.size > 0:
                        self.ln_phase.set_data(px, py)
                        if px.size > 1:  # Need at least 2 points for xlim
                            self.ax_phase.set_xlim(px.min(), px.max())

                if fx.size and fy.size and fx.size == fy.size:
                    # Ensure data is valid for matplotlib
                    if fx.size > 0 and fy.size > 0:
                        self.ln_fm.set_data(fx, fy)
                        if fx.size > 1:  # Need at least 2 points for xlim
                            self.ax_fm.set_xlim(fx.min(), fx.max())
                        ymin, ymax = np.nanmin(fy), np.nanmax(fy)
                        if np.isfinite(ymin) and np.isfinite(ymax) and ymin < ymax:
                            self.ax_fm.set_ylim(ymin - 50, ymax + 50)

                self.fig2.canvas.draw_idle()

            elif typ == "psk":
                self.last_psk = obj
                self.last_msg_hex = obj.get("hex")


    def clean_exit(self, code: int = 0):
        # Остановить таймер
        try:
            self._timer.stop()
        except Exception:
            pass
        # Закрыть ZMQ/клиент
        try:
            self.client.close()
        except Exception:
            pass
        # Закрыть окна
        try:
            import matplotlib.pyplot as _plt
            _plt.close('all')
        except Exception:
            pass
        # Stop auto-started service
        try:
            if getattr(self, '_svc_proc', None):
                self._svc_proc.terminate()
        except Exception:
            pass
        # Финальный выход
        import sys
        sys.exit(code)

    def _on_close(self, _evt):
        self.clean_exit(0)

    def _on_key(self, evt):
        if evt.key in ('q', 'escape'):
            self.clean_exit(0)

    # ---------- UI callbacks ----------
    def _on_backend_select(self, backend_name: str):
        # For file backend, ask for file first
        if backend_name == "file":
            try:
                root = tk.Tk(); root.withdraw()
                path = filedialog.askopenfilename(
                    title="Выберите CF32 или SigMF",
                    filetypes=[("CF32", "*.cf32"), ("F32", "*.f32"), ("SigMF", "*.sigmf-meta"), ("All", "*.*")]
                )
                root.destroy()
                if not path:
                    return  # User cancelled
            except Exception as e:
                print("file open err:", e)
                return
        else:
            path = None

        # Stop current acquisition
        print("[backend] stop_acquire", self.client.stop_acquire())
        time.sleep(0.2)  # Small delay for service to process stop

        # Get current config and update it
        cfg_resp = self.client.get_sdr_config()
        if cfg_resp and "config" in cfg_resp:
            cfg = cfg_resp["config"]  # DSP service returns config in nested structure
        else:
            cfg = {}

        # Update backend and file parameters
        cfg["backend_name"] = backend_name
        if backend_name == "file" and path:
            cfg["backend_args"] = path  # Pass file path as backend_args
            cfg["bb_shift_enable"] = False
            cfg["bb_shift_hz"] = 0

        # Apply config - send directly without 'config' wrapper
        print(f"[set_sdr_config] backend={backend_name}, file={path}")
        rep = self.client.set_sdr_config(**cfg)
        print("[set_sdr_config result]", rep)
        time.sleep(0.2)  # Small delay for service to process config change

        # Restart acquisition
        print("[backend] start_acquire", self.client.start_acquire())

    def _on_file_select(self, _event):
        # This is the same as selecting File backend
        self._on_backend_select("file")

    def _on_exit(self, _event):
        self.clean_exit(0)

    def _on_show_spectrum(self, _event):
        print("[info] Спектр вызывается кнопкой. Ожидайте pulse с fr_* данными.")

    def _on_show_sdr_status(self, _event):
        st = self.client.get_status()
        fig, ax = plt.subplots(figsize=(9, 6))
        ax.axis("off")
        ax.set_title("SDR Status (snapshot)")
        lines = []
        if isinstance(st, dict):
            for k, v in st.items():
                lines.append(f"{k}: {v}")
        else:
            lines.append("нет данных")
        ax.text(0.02, 0.98, "\\n".join(lines), va="top", ha="left", family="monospace")
        plt.tight_layout(); plt.show(block=False); plt.pause(0.1)

    def _on_show_params(self, _event):
        p = self.last_psk or {}
        rows = [
            ("length_ms", p.get("length_ms")),
            ("preamble_ms", p.get("preamble_ms")),
            ("baud", p.get("baud")),
            ("pos_phase", p.get("pos_phase")),
            ("neg_phase", p.get("neg_phase")),
            ("rise_us", p.get("rise_us")),
            ("fall_us", p.get("fall_us")),
            ("asymmetry_pct", p.get("asymmetry_pct")),
            ("hex", p.get("hex")),
        ]
        fig, ax = plt.subplots(figsize=(8, 4.5)); ax.axis("off")
        ax.set_title("Phase Parameters (snapshot)")
        txt = "\\n".join(f"{k:>14}: {v}" for k, v in rows)
        ax.text(0.02, 0.98, txt, va="top", ha="left", family="monospace")
        plt.tight_layout(); plt.show(block=False); plt.pause(0.1)

    def _on_save_sigmf(self, _event):
        rep = self.client.save_sigmf()
        print("[save_sigmf]", rep)

    def _on_toggle_updates(self, _event):
        self._updates_enabled = not self._updates_enabled
        self.btn_stop.label.set_text("Пуск" if not self._updates_enabled else "Стоп")

    def _on_show_message(self, _event):
        hex_msg = self.last_msg_hex
        fig, ax = plt.subplots(figsize=(8, 3))
        try: fig.canvas.manager.set_window_title("Декодированное сообщение")
        except Exception: pass
        ax.axis('off')
        if not hex_msg:
            ax.text(0.5, 0.5, "Нет сообщения.\\nСначала должен быть обнаружен PSK импульс.",
                    ha='center', va='center', fontsize=12)
        else:
            ax.text(0.5, 0.5, f"HEX: {hex_msg}", ha='center', va='center', fontsize=12, family="monospace")
        plt.tight_layout(); plt.show(block=False); plt.pause(0.1)


# -------------------- Auto-start dsp_service --------------------
import subprocess
from shutil import which

def _candidate_service_paths() -> list:
    here = Path(__file__).resolve().parent
    names = [
        "beacon_dsp_service.py",
        str(here / "beacon_dsp_service.py"),
        str(here.parent / "beacon_dsp_service.py"),
        str(here / "beacon406" / "beacon_dsp_service.py"),
        str(here / "beacon406" / "apps" / "beacon_dsp_service.py"),
        str(Path.cwd() / "beacon_dsp_service.py"),
        "/mnt/data/beacon_dsp_service.py",
    ]
    out = []
    for n in names:
        try:
            pn = Path(n)
            if pn.exists():
                out.append(str(pn))
        except Exception:
            pass
    # dedup, keep order
    seen = set()
    uniq = []
    for s in out:
        if s not in seen:
            seen.add(s)
            uniq.append(s)
    return uniq

def _spawn_service_if_needed(client):
    """Try get_status(); if it fails, spawn the service without args and wait until ready."""
    try:
        # Use quick check to avoid hanging on startup
        rep = client.quick_status_check()
        if isinstance(rep, dict) and rep.get("ok", True):
            return None  # already running
    except Exception:
        pass
    # locate file and spawn
    for cand in _candidate_service_paths():
        try:
            py = sys.executable or which("python") or which("python3")
            if not py:
                break
            print(f"[auto] launching dsp_service: {py} {cand}")
            proc = subprocess.Popen([py, cand], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            # wait up to ~6s for readiness
            import time
            t0 = time.time()
            while time.time() - t0 < 6.0:
                try:
                    rep = client.quick_status_check()
                    if isinstance(rep, dict):
                        print("[auto] dsp_service is ready")
                        return proc
                except Exception:
                    pass
                time.sleep(0.4)
            try:
                proc.terminate()
            except Exception:
                pass
        except Exception as e:
            print("[auto] launch error:", e)
    print("[auto] dsp_service not found or failed to start")
    return None

# -------------------- main --------------------
def parse_args(argv):
    import argparse
    ap = argparse.ArgumentParser(description="beacon_dsp2plot — UI для beacon_dsp_service")
    ap.add_argument("--pub", default=PUB_ADDR_DEFAULT, help="ZeroMQ PUB адрес сервиса")
    ap.add_argument("--rep", default=REP_ADDR_DEFAULT, help="ZeroMQ REP адрес сервиса")
    ap.add_argument("--autostart", action="store_true", help="Отправить start_acquire при запуске")
    return ap.parse_args(argv)

def main(argv=None):
    args = parse_args(sys.argv[1:] if argv is None else argv)
    ui = Dsp2PlotUI(pub_addr=args.pub, rep_addr=args.rep)
    # auto-start service if not running
    try:
        proc = _spawn_service_if_needed(ui.client)
        if proc is not None:
            ui._svc_proc = proc
    except Exception as _e:
        print('[auto] spawn skipped:', _e)

    def _sig(_signum, _frame):
        try:
            ui.clean_exit(0)
        except SystemExit:
            pass
    for sig in (signal.SIGINT, signal.SIGTERM):
        try:
            signal.signal(sig, _sig)
        except Exception:
            pass

    try:
        print('[startup] start_acquire', ui.client.start_acquire())
    except Exception as _e:
        print('[startup] start_acquire skipped:', _e)
    if args.autostart:
        print(ui.client.start_acquire())
    plt.show()

if __name__ == "__main__":
    main()
