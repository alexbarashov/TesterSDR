# ТЗ: Перевести «уровень SDR» веб-приложения на `_dsp_service` (без изменения UI)

## 0) Контекст (что уже есть)

* Веб-приложение `beacon_tester_web.py` сейчас само инициализирует SDR через `lib.backends.safe_make_backend`, крутит чтение сэмплов, считает RMS, ловит импульсы и т.д., выдавая REST `/api/status`, `/api/measure`, `/api/run`, `/api/break`, `/api/state`, `/api/last_pulse` и пр.    
* Headless-сервис `beacon_dsp_service.py` уже реализует весь DSP цикл, ZeroMQ **PUB** (эвенты `status/pulse/psk`) и **REP** (команды `echo/get_status/start_acquire/stop_acquire/set_params/get_last_pulse`), а также авто-подбор/инициализацию бэкенда (в т.ч. `auto`/`soapy_*`/`rsa306`/`file`). Адреса по умолчанию: `--pub tcp://127.0.0.1:8781`, `--rep tcp://127.0.0.1:8782`.   

**Цель:** веб больше **не** читает SDR и не демодулирует — он **только** общается с `_dsp_service` и показывает полученные данные. Внешний UI/поведение страниц — без изменений.

---

## 1) Процесс/архитектура

1. Запуск `_dsp_service` отдельно (как «движок»). Веб к нему подключается:

   * REP сокет клиента → `tcp://127.0.0.1:8782` (команды и запросы данных).
   * SUB сокет клиента → `tcp://127.0.0.1:8781` (подписка на темы `status`, `pulse`, `psk`). 

2. Во **веб-коде** удалить прямую работу с SDR (init / read / RMS / очередь импульсов и т.п.) и заменить источники данных на:

   * **Пассивные**: подписка на PUB (`status/pulse/psk`) для потока реального времени.
   * **Активные**: разовые REP-команды (`get_status`, `get_last_pulse`, `start_acquire`, `stop_acquire`, `set_params`, `echo`) по необходимости. 

> Замечание: адреса, имена команд и формат ответов брать из `beacon_dsp_service.py`. 

---

## 2) Маппинг существующих REST endpoint-ов веба на команды сервиса

> Важно: **сигнатуры REST-роутов веба не меняем**, только их реализацию внутри.

### `/api/measure` (кнопка «Measure»)

* Было: локальный `init_sdr_backend()` и проверка устройства. 
* Стало: выполнить `REP: get_status` у сервиса и вернуть в ответе то, что раньше возвращали про «SDR initialized/device info», но на основе полей статуса сервиса:
  `status.backend`, `status.backend_args`, `status.acq_state`, `status.ready`, `status.fs`, `status.bb_shift_hz`, а также downsampled RMS `t_s` + `last_rms_dbm` (если есть).  
* Никакого локального SDR в вебе не поднимать.

### `/api/run` (Start)

* Было: локальный `stop_sdr_capture()` → `start_sdr_capture()` и флаг `STATE.running=True`. 
* Стало: `REP: start_acquire` и возвращаем `running=True` **если** `acq_state` сервиса в ответе ≠ `stopped` (лучше `running`). 

### `/api/break` (Stop)

* Было: локальный `stop_sdr_capture()` и `STATE.running=False`. 
* Стало: `REP: stop_acquire`, `running=False` по результату (`acq_state=stopped`). 

### `/api/status` (главный поллинг UI)

* Было: читали локальные структуры (`STATE.*`, `current_rms_dbm`, `pulse_queue`, `sdr_backend.get_status()`). 
* Стало: комбинировать:

  1. последнюю «липкую» копию `status` из PUB-событий (если подписка активна),
  2. при необходимости — разовый `REP: get_status` (fallback),
  3. последнюю «липкую» копию `pulse/psk` для «latest_pulse» и фаз/FR.
* Поля ответа API **должны остаться прежними**, маппим их из статуса/пульса сервиса. Если чего-то нет — аккуратные `None`/пустые списки как сейчас.

### `/api/state` / `/api/last_pulse`

* Было: возвращали внутренние буферы веба, историю импульсов и т.п. 
* Стало: отдавать **кэш из сервиса**:

  * «Историю» и «последний импульс» поддерживать локально в вебе, но **заполнять** только из событий PUB (`pulse`/`psk`) и/или `REP: get_last_pulse` (если хотим подтянуть фазу/FR с нарезкой). Форматы брать из `_dsp_service`.  

---

## 3) Подписка на PUB и структура событий

* Завести во фронтенд-бэкенде (внутри Flask-процесса) **фоновый поток** SUB-клиента ZeroMQ, подписанный на темы:

  * `"status"` — содержит сводные поля сервиса и downsampled RMS (`t_s`, `last_rms_dbm`) — те же поля доступны и через `get_status`. 
  * `"pulse"` — событие с метриками импульса и, при наличии, кратким IQ/окном ядра. 
  * `"psk"` — событие с `preamble_ms`, `baud`, `pos_phase`, `neg_phase`, `rise_us`, `fall_us`, `asymmetry_pct`, `hex`. 

* Все события **кэшировать** в потокобезопасных структурах (lock/queue/deque) — так, как делалось в вебе раньше для локальной обработки, но теперь источник — `_dsp_service`.

---

## 4) REP-команды, которые веб должен уметь слать

1. `echo` — самотест канала.
2. `get_status` — получить текущий сводный статус (в т.ч. `backend`, `acq_state`, `ready`, `fs`, `bb_shift_hz`, `t_s`, `last_rms_dbm`).  
3. `start_acquire` / `stop_acquire` — запуск/останов захвата. 
4. `set_params` — минимум поддержать `thresh_dbm` и `target_signal_hz` (UI может выставлять порог и целевую частоту — оставить те же элементы управления, просто прокидывать параметр). 
5. `get_last_pulse` — получить **последний** импульс с фазой/FR и **slice-API** (offset/span/units/max_samples/downsample), чтобы не тянуть мегамассивы. Веб может дергать это по требованию (например, по клику «обновить фазу»). 

---

## 5) Конфиг и режимы

* По умолчанию веб подключается к `REP=tcp://127.0.0.1:8782`, `PUB=tcp://127.0.0.1:8781`. Сделать параметры конфигурируемыми через env/ini, но дефолты — как в сервисе. 
* Веб **не создаёт** `safe_make_backend` и не держит NCO/кольцевой буфер — всё это уже в сервисе. Удалить/заглушить локальные структуры SDR в вебе (reader thread, NCO, RMS и т.д.), но **сохранить интерфейсы REST** (см. раздел 2).  

---

## 6) Ошибки и устойчивость

* Если нет связи с сервисом (REP timeout или SUB молчит) — REST эндпоинты возвращают `running=False`, пустые массивы и сообщение об ошибке в поле `message` (не ломая текущий JSON-контракт).
* При отвале SUB-потока — автоматическая переподписка с бэкоффом.
* Репортинг через существующий логгер веба (уровни оставить как есть).

---

## 7) Совместимость UI (must-have)

* **Визуально и по API** для фронтенда ничего не меняется:

  * те же маршруты `/api/status`, `/api/measure`, `/api/run`, `/api/break`, `/api/state`, `/api/last_pulse`;
  * те же JSON-поля (включая `phase_data/xs_ms`, `fm_data/fm_xs_ms`, `pos_phase/neg_phase`, `preamble_ms`, `bitrate_bps`, `symmetry_pct`, `rms_dbm`, `freq_hz`, и т.д.). Питаться данными теперь из сервиса (PUB + `get_last_pulse`/`get_status`).  

---

## 8) Критерии приёмки

1. При запущенном `_dsp_service` на дефолтных адресах:

   * Нажатие «Measure» возвращает актуальный `backend`, `acq_state`, `fs`, `bb_shift_hz`, `ready=True/False` — **без** локального SDR. 
2. «Start»/«Stop» управляют захватом через `start_acquire`/`stop_acquire`; поле `running` в ответах REST соответствует `acq_state` сервиса. 
3. `/api/status` показывает живой уровень RMS и последние импульсы, хотя веб не читает SDR сам (данные идут через PUB/REP). 
4. `/api/last_pulse` и «графики фазы/FM» получают данные от сервиса (из PUB или `get_last_pulse`), длины массивов согласованы (нет предупреждений о mismatch).  
5. Если сервис не запущен, UI грузится, REST работают, но возвращают «не подключено» с корректным сообщением и пустыми данными — без падений.

---

## 9) Нюансы реализации

* **Подписка SUB**: создать отдельный поток слушателя ZeroMQ, парсить envelope-тему (`"status"`, `"pulse"`, `"psk"`), обновлять thread-safe кэши. 
* **Синтез «history»**: история импульсов в вебе теперь формируется **из** входящих `pulse/psk` (лимит, например, 50 — как было). Формат в ответах REST — прежний. 
* **Slice API**: на кнопках/эндоинтах, где нужно точнее фазу/FM, используй `REP: get_last_pulse` с `slice`/`max_samples`/`downsample` — сервис это умеет. 
* **Параметры порога и частоты**: если UI даёт управлять порогом (`PULSE_THRESH_DBM`) или целевой частотой — прокидывай через `set_params`. 
* **Адреса/порты**: брать из CLI сервиса по умолчанию либо из ENV; в вебе добавить лёгкую обвязку (env/ini). 

