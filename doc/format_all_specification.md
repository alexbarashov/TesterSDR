# Техническое задание: Формат файлов .ALL для тестера радиомаяков GMDSS

## Общие сведения

### Назначение формата
Формат файлов `.all` предназначен для хранения результатов измерений параметров аварийных радиомаяков GMDSS (Global Maritime Distress and Safety System), работающих на частотах 406 МГц и 121.5 МГц.

### Область применения
- Сохранение данных измерений сигналов радиомаяков
- Передача результатов тестирования между программными модулями
- Архивирование измерительной информации
- Генерация отчетов о тестировании

### Характеристики формата
- **Тип файла**: Бинарный
- **Расширение**: `.all`
- **Порядок байт**: Little Endian (Intel x86)
- **Кодировка**: Бинарные структуры данных C++
- **Версионность**: Поддерживается обратная совместимость с legacy форматами

## Структура файла

Файл `.all` состоит из последовательных секций, записанных в строгом порядке:

### Legacy формат (до версии 3.01a) - наиболее распространенный:
```
[Единственная секция]
├── PreFullData (заголовок коллекции измерений) - 8 байт
├── FullData[] (массив измерений) - count × 16 байт
├── PostFullData (маркер окончания) - 2 байта
└── BT_PhaseData (фазовые данные и метаданные) - ~2400-2500 байт
```

### Новый формат (версия 3.01a+) - теоретический:
```
[Секция FullData]
├── PreFullData (заголовок коллекции измерений)
├── FullData[] (массив измерений)
├── PostFullData (маркер окончания)
├── BT_PhaseData (фазовые данные и метаданные)
[Секция RealFullData] (дополнительная секция)
├── PreFullData (заголовок коллекции)
├── RealFullData[] (массив измерений в физических единицах)
├── PostFullData (маркер окончания)
├── D406AddData (дополнительные данные 406 МГц)
```

## Спецификация структур данных

### 1. PreFullData - Заголовок коллекции
```c
typedef struct {
    unsigned short par1;    // == 0x0032 (магический номер)
    unsigned short count;   // количество элементов FullData в коллекции
    unsigned short par2;    // == 0x0064 (контрольное значение)
    unsigned short par3;    // == 0x0064 (контрольное значение)
} PreFullData;
```
**Размер**: 8 байт

### 2. FullData - Основные измерительные данные
```c
typedef struct {
    unsigned short objectid;  // == FULLDATAOBJECTID (1021) - маркер типа объекта
    char Data[10];           // массив измерительных данных (см. ниже)
    long STime;              // временная метка в отсчетах 100 Гц
} FullData;
```
**Размер**: 16 байт
**Фактическое значение objectid в файлах**: `FD 03` (0x03FD в little-endian = 1021)

#### Расшифровка массива Data[10]:
- `Data[0]` - Мощность (Power)
- `Data[1]` - Частота (Frequency)
- `Data[2]` - Средний наклон частоты (Mean Slope)
- `Data[3]` - Остаточные вариации (Residual Variations)
- `Data[4]` - Краткосрочная стабильность (Short-Term Stability)
- `Data[5]` - Положительная фаза модуляции (Ph+)
- `Data[6]` - Отрицательная фаза модуляции (Ph-)
- `Data[7]` - Время нарастания (Rise Time)
- `Data[8]` - Время спада (Fall Time)
- `Data[9]` - RMS значение

### 3. PostFullData - Маркер окончания коллекции
```c
typedef struct {
    unsigned short post;  // == PHASEDATAOBJECTID (1022)
} PostFullData;
```
**Размер**: 2 байта
**Фактическое значение в файлах**: `FE 03` (0x03FE в little-endian = 1022)

### 4. BT_PhaseData - Фазовые данные и метаданные
```c
typedef struct {
    BT_MPhaseByteData PhasePictureData;  // Массив исходных данных фазы [1000 байт]
    BT_DiskData TablData1;               // Текущие данные 406 МГц
    BT_LongData TablData2;               // Долгосрочные характеристики
    BT_CalcData TablData3;               // Вычисленные Min/Max значения
    BT_CalcData121 TablData121;          // Данные 121.5 МГц
    BT_Dop TablDop;                      // Дополнительные параметры
} BT_PhaseData;
```
**Размер**: ~2400-2500 байт (точный размер зависит от версии и выравнивания структур)

#### BT_DiskData - Текущие измерения
```c
typedef struct {
    short TransNum;          // Номер передачи
    long STime;              // Временная метка (100 Гц)
    Real FS1, FS2, FS3;      // Частотные измерения
    Real BitRate;            // Скорость передачи данных
    Real MinusP, PlusP;      // Отрицательная/положительная фаза
    Real TRise, TFall;       // Времена нарастания/спада
    Real Symmetry;           // Симметрия модуляции
    Real Preamble;           // Длительность преамбулы
    Real Total;              // Общее время
    Real Power;              // Мощность
    Real Prise;              // Мощность нарастания
    Real RepPeriod;          // Период повторения
    unsigned char NumMes;    // Номер сообщения
    unsigned char MesCont[18]; // Содержимое сообщения
    unsigned char StopBit;   // Стоп-бит
} BT_DiskData;
```

### 5. RealFullData - Данные в физических единицах (с версии 3.01a)
```c
typedef struct {
    unsigned short objectid;  // == FULLDATAOBJECTID (1021)
    double Data[10];         // массив в физических единицах
    long STime;              // временная метка в отсчетах 100 Гц
} RealFullData;
```
**Размер**: 92 байта

#### Расшифровка массива Data[10] для RealFullData:
- `Data[0]` - Мощность, Вт (Power, W)
- `Data[1]` - Частота, МГц (Frequency, MHz)
- `Data[2]` - Средний наклон (Mean Slope)
- `Data[3]` - Остаточные вариации (Residual Variations)
- `Data[4]` - Краткосрочная стабильность (Short-Term Stability)
- `Data[5]` - Положительная фаза, рад (Ph+, rad)
- `Data[6]` - Отрицательная фаза, рад (Ph-, rad)
- `Data[7]` - Время нарастания, мсек (Rise Time, msec)
- `Data[8]` - Время спада, мсек (Fall Time, msec)
- `Data[9]` - RMS значение

## Константы и идентификаторы

```c
#define FULLDATAOBJECTID     1021  // Идентификатор объекта измерительных данных
#define PHASEDATAOBJECTID    1022  // Идентификатор объекта фазовых данных
```

## Алгоритм чтения файла

1. **Чтение основной секции (всегда присутствует):**
   - Прочитать `PreFullData` (8 байт)
   - Проверить `par1 == 0x0032` (магический номер)
   - Проверить `par2 == 0x0064` и `par3 == 0x0064` (контрольные значения)
   - **Внимание**: `par2` может быть в формате `0x00C2` в файле (little-endian)
   - Прочитать `count` записей `FullData` (по 16 байт каждая)
   - Проверить `objectid == 0x03FD` (1021 в little-endian) для каждой записи
   - Прочитать `PostFullData` (2 байта)
   - Проверить `post == 0x03FE` (1022 в little-endian)
   - Прочитать `BT_PhaseData` до конца файла (для legacy формата)

2. **Чтение секции RealFullData (если присутствует - новый формат):**
   - Определить наличие дополнительных данных после BT_PhaseData
   - Прочитать `PreFullData` (8 байт)
   - Проверить заголовок (`par1 == 0x0032`)
   - Прочитать `count` записей `RealFullData` (по 92 байта каждая)
   - Прочитать `PostFullData` и `D406AddData`

3. **Обработка ошибок:**
   - При несоответствии магических чисел - прекратить чтение
   - При ошибках чтения - вернуть код ошибки
   - Legacy файлы без RealFullData считать валидными (это норма)

## Алгоритм записи файла

1. **Подготовка данных:**
   - Заполнить коллекции `FullData` и `RealFullData`
   - Установить идентификаторы объектов

2. **Запись первой секции:**
   - Записать `PreFullData` с количеством элементов
   - Записать массив `FullData`
   - Записать `PostFullData` с `PHASEDATAOBJECTID`
   - Записать `BT_PhaseData`

3. **Запись секции RealFullData:**
   - Записать `PreFullData` для Real данных
   - Записать массив `RealFullData`
   - Записать `PostFullData`
   - Записать `D406AddData`

## Особенности реализации

### Типы данных
- `Real` - тип данных с плавающей точкой (размер зависит от реализации)
- `long` - 32-битное целое со знаком
- `unsigned short` - 16-битное целое без знака
- `unsigned char` - 8-битное целое без знака

### Совместимость и версионность
- **Legacy формат (до версии 3.01a)**: Содержит только одну секцию FullData + BT_PhaseData
- **Новый формат (версия 3.01a+)**: Дополнительно содержит секцию RealFullData + D406AddData
- При чтении legacy файлов секция RealFullData отсутствует - это нормально
- Большинство файлов в проекте используют legacy формат

### Обработка ошибок
- Проверка магических чисел обязательна
- Несоответствие размеров данных критично
- Повреждение структур требует прекращения обработки

### Производительность
- Чтение/запись выполняется блоками через `read_buf()/write_buf()`
- Буферизация данных для оптимизации I/O операций
- Проверка целостности на каждом этапе

## Примеры использования

### Создание файла .all
```c
// Инициализация структур
PreFullData preData = {0x32, count, 0x64, 0x64};
FullData fd[count];
PostFullData postData = {PHASEDATAOBJECTID};

// Запись данных
write_buf(file, &preData, sizeof(preData));
for(int i = 0; i < count; i++) {
    fd[i].objectid = FULLDATAOBJECTID;
    write_buf(file, &fd[i], sizeof(fd[i]));
}
write_buf(file, &postData, sizeof(postData));
```

### Чтение файла .all
```c
PreFullData preData;
read_buf(file, &preData, sizeof(preData));
if(preData.par1 != 0x32) {
    // Ошибка формата файла
    return ERROR;
}

for(int i = 0; i < preData.count; i++) {
    FullData fd;
    read_buf(file, &fd, sizeof(fd));
    if(fd.objectid != FULLDATAOBJECTID) {
        // Поврежденные данные
        return ERROR;
    }
    // Обработка измерения
}
```

## Практические наблюдения из реальных файлов

### Статистика по файлам проекта:
- **China.all**: 1 запись, общий размер 2516 байт, BT_PhaseData = 2490 байт
- **savenew.all**: 91 запись, общий размер 3870 байт, BT_PhaseData = 2404 байт
- **U11029_test.all**: 455 записей, общий размер 56920 байт

### Фактические hex-значения в файлах:
```
PreFullData: 32 00 [count_low] [count_high] 00 C2 64 00
FullData:    FD 03 [10_data_bytes] [4_time_bytes]
PostFullData: FE 03
```

### Важные замечания:
1. **Все найденные файлы используют legacy формат** - секция RealFullData не обнаружена
2. **Размер BT_PhaseData варьируется** (2404-2490 байт) - возможно, из-за выравнивания структур
3. **Little-endian байт-ордер** подтвержден анализом реальных файлов

## Заключение

Формат `.all` представляет собой строго структурированный бинарный формат для хранения результатов измерений радиомаяков GMDSS. Формат обеспечивает надежное хранение данных с контролем целостности и поддержкой обратной совместимости.

Ключевые особенности:
- Бинарная структура для эффективного хранения
- Встроенные механизмы контроля целостности
- Поддержка версионности и обратной совместимости
- Разделение raw данных и данных в физических единицах
- Комплексная структура метаданных для полного описания измерений