ок, вот готовое ТЗ для Claude: что именно правим в `beacon_dsp2plot.py` и как тестируем. Можно вставлять как первый пост.

# ТЗ: Правки `beacon_dsp2plot.py` + тест-план

## Цель

Переключить UI на работу с обновлённым сервисом (мгновенный ACK, долгие действия в фоне) и добиться стабильного обновления графиков (RMS/Phase/FM) и мгновенной реакции кнопок, включая файловый режим без таймаутов.

---

## Что именно правим в `beacon_dsp2plot.py`

### 1) Транспорт и команды (мгновенный ACK)

* Ввести тонкую обёртку `send_cmd(name, **kwargs)`:

  * Сериализует запрос, отправляет сервису, **не блокируется дольше короткого таймаута**, читает быстрый ACK (json `{ok: bool, error?: str}`).
  * Печатает `"[cmd=<name>] ack=<dt_ms> ms → <rep>"`.
  * Ошибку в ACK не роняет UI: показывает в статус-баре/консоли, UI остаётся жив.
* Оставить только команды: `echo`, `get_status`, `start_acquire`, `stop_acquire`, `set_sdr_config`, `save_sigmf`.

### 2) Инициализация и главный цикл (single poll)

* При запуске:

  1. `echo` (проверка канала)
  2. `get_status` (снимок)
  3. Если `--autostart`: **ровно один** вызов `start_acquire`.
* Перевести UI на **одинарный цикл опроса**:

  * Один таймер/loop `poll_status()` с периодом ~200–500 мс.
  * Никаких параллельных потоков и повторных опросов.
  * `poll_status()`:

    * вызывает `get_status`,
    * обновляет индикаторы состояния/кнопки,
    * при наличии новых данных — перерисовывает графики.

### 3) Кнопки / события UI

* **Start** → `start_acquire` через `send_cmd` (не ждать «долго»; всё состояние видим в `get_status`).
* **Stop** → `stop_acquire`.
* **Backend** (выпадающий список):

  * Значения: `auto`, `file`, `soapy_rtl`, `soapy_hackrf`, `soapy_airspy`, `soapy_sdrplay`, `rsa306`.
  * При выборе `file`: показать диалог выбора файла и вызвать

    ```python
    set_sdr_config(backend="file", backend_args={"path": <chosen_path>}, bb_shift_hz=0)
    ```
  * После ACK **не** ждать синхронно — просто ждать в `poll_status()` смены статуса `retuning → ready`.
* **Open file…** (если отдельная кнопка): эквивалент выбора файла в `file`-режиме.
* **Save (SigMF)** → `save_sigmf` через `send_cmd` + всплывашка «сохранено» по `ok:true`.

**Анти-дребезг:** блокировать повторную отправку одной и той же команды, пока предыдущий ACK не получен (простой флаг in-flight на 150–300 мс).

### 4) Строка статуса (StatusPanel)

Вывести одну строку вверху окна (или в статус-бар):

```
backend=<...> | state=<...> | ready=<...> | fs=<...> | bb_shift=<...> | thresh=<...>
```

* Поля брать из последнего `get_status`.
* Если `state=retuning` — подсветить/иконка «ретюн».

### 5) Графики и данные

* Источник данных — **только** `get_status` (downsample RMS и метаданные).
* Рендер:

  * Верх — Phase
  * Ниже — FM (общая ось X с Phase)
  * Слева — RMS (можно отдельная ось X, но обновление синхронно с остальными)
* Требования к поведению:

  * В `file`-режиме **после** того как статус стал `ready=True` — показать данные сразу (без ожидания «импульсов»).
  * Отсутствие нового сигнала не должно «ломать» оси и рендер — держать последнюю разметку осей, переиспользовать буфер данных.
  * Не допускать гонок: перерисовка только из `poll_status()`.

### 6) Логирование

* При старте UI:

  * Печать уровня логирования (например: `LOG=INFO`/`DEBUG`) и адреса сервиса (REP/PUB).
* На каждую команду в консоль:

  * `"[cmd=...] ack=... ms → {ok: ...}"`.
* Ошибки ACK — кратко и без стека (UI не падает).

### 7) Состояния и блокировки кнопок

* Во время `retuning`: кнопки **можно не блокировать**, но статус явно показывает `retuning`.
* При явной ошибке ACK — подсветка ошибки в строке статуса на 2–3 секунды.
* Кнопки Start/Stop отражают `acq_state`:

  * если `acq_state=running` → Start неактивна, Stop — активна;
  * если `stopped` → наоборот.

---

## Тест-план (ручной, быстрый)

### Подготовка

* Запустить сервис (адрес REP/PUB известен UI).
* Проверочный файл: `C:/work/TesterSDR/captures/psk406msg_f100.cf32` (или другой валидный `.cf32`).
* Запуск UI:

  * Без аргументов
  * И с `--autostart`

### Тест 1: Старт без SDR, только файл

1. UI стартует → `echo` OK, `get_status` OK.
2. В UI выбрать `Backend=file` → диалог файла → указать `.cf32`.
3. Проверить, что в статусе видно: `state=retuning` → затем `ready=True`.
4. Графики (RMS/Phase/FM) появились, UI отзывчив.
5. Нажать `Start` → `Stop` → `Start` → `Stop` (по два раза).

   * Команды дают быстрый ACK, UI не «виснет».

**Критерии:** ACK < 200–300 мс; нет таймаутов; графики рендерятся после `ready=True`.

### Тест 2: Переключение бекендов

1. `file → auto → file`.
2. На каждом переходе видим `retuning → ready`, графики/статус не «залипают».
3. В `auto` режиме допускается `ready=False` (если нет SDR) — UI не падает, кнопки живые.

**Критерии:** нет зависаний; переходы отображаются корректно.

### Тест 3: SPAM нажатия

1. Быстро нажать `Start` 5–10 раз подряд.
2. Затем `Stop` 5–10 раз подряд.
3. Никаких исключений/таймаутов, in-flight защита работает, UI остаётся отзывчив.

**Критерии:** отсутствие падений; команды агрегируются/игнорируются корректно.

### Тест 4: Автозапуск

1. Запустить UI с `--autostart`.
2. Проверить, что `start_acquire` отправляется **один раз**, далее работает только polling.

**Критерии:** нет повторных start; лог подтверждает единственный `start`.

### Тест 5: Неверный файл

1. В `file` выбрать отсутствующий/пустой путь.
2. Получить ACK `{ok:false, error:"..."}` — UI не падает; статус показывает проблему.
3. Исправить путь → выбрать валидный файл → `retuning → ready` → графики есть.

**Критерии:** устойчивость к ошибкам ввода; корректное восстановление.

---

## Готовые «куски» для вставки

**send_cmd / poll_status (псевдокод)**

```python
def send_cmd(self, name, **kw):
    t0 = time.perf_counter()
    rep = self.client.call(name, **kw)  # быстрый ACK
    dt = (time.perf_counter() - t0) * 1000
    print(f"[cmd={name}] ack={dt:.1f} ms → {rep}")
    # rep = {"ok": bool, "error"?: str, ...}
    if not rep.get("ok", False):
        self.flash_status_error(rep.get("error", "unknown error"))
    return rep

def poll_status(self):
    st = self.client.call("get_status") or {}
    self.last_status = st
    self.update_status_bar(st)
    self.update_buttons(st)
    if self.status_has_new_data(st):
        self.update_plots(st)
```

**Строка статуса**

```python
def update_status_bar(self, s):
    txt = "backend={b} | state={st} | ready={r} | fs={fs:.0f} | bb_shift={bb:.0f} | thresh={th:.1f}".format(
        b=s.get("backend","?"), st=s.get("acq_state","?"), r=s.get("ready", False),
        fs=s.get("fs", 0) or 0, bb=s.get("bb_shift_hz", 0) or 0, th=s.get("thresh_dbm", 0) or 0
    )
    self.fig1.suptitle(txt)
    # при st=="retuning" можно изменить цвет/иконку
```

---

## Критерии приёмки (Definition of Done)

* Кнопки не подвешивают интерфейс; ACK виден в логе и приходит быстро.
* Один цикл опроса (single poll), без гонок/параллельных запросов.
* В `file`-режиме после `retuning → ready` графики стабильно появляются.
* Переключение backend’ов и многократные `start/stop` устойчивы.
* Ошибки ACK не убивают UI; статус их кратко показывает.
* При старте логируется уровень логирования и адрес сервиса.

---

## Что предоставить по завершении

* Обновлённый `beacon_dsp2plot.py`.
* Короткий лог запуска (`echo`, `get_status`, `--autostart` поведение).
* Скриншот с видимым статус-баром и графиками в `file`-режиме.
* (Опционально) небольшой GIF с переключением `file → auto → file` и SPAM-нажатиями.
