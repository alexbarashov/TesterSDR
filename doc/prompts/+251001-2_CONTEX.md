Отличная трасса — спасибо! По логам видно корневую причину «смерти» кнопок после первых команд.

## Что сломалось (коротко)

* `stop_acquire` внутри REP-потока вызывает `self.stop()`.
* Внутри `self.stop()` выставляется флаг `self._stop = True`.
* И **reader-loop**, и **REP-loop** крутятся на одном и том же флаге `self._stop`.
* Как только вы вызвали `stop_acquire`, **REP-loop тоже вышел** из цикла — сервис перестал отвечать на все последующие команды (`start`, `set_sdr_config`, …) → таймауты.

(Это объясняет: первый `start/stop` ещё ACK, а дальше **всё** уходит в TIMEOUT.)  

---

## Мини-фикс (чёткий план правки)

### 1) Развести флаги «стопа»

* В классе `BeaconDSPService` введите два независимых флага:

  * `self._reader_stop` — только для **reader_loop** (поток чтения SDR/файла).
  * `self._service_stop` — только для **graceful shutdown** всего сервиса (закрыть ZMQ и выйти из `__main__`).

### 2) Правки методов

* `start()`:

  * Сбрасывает **только** `self._reader_stop = False`.
* `stop()`:

  * Ставит **только** `self._reader_stop = True`, делает `join(timeout=1.0)` у `reader_thread`, **не трогает** никакие ZMQ/REP переменные, **не** меняет `_service_stop`.
* Добавить `shutdown()`:

  * Ставит `self._service_stop = True`, закрывает сокеты REP/PUB, executor, и в `__main__` ловим `KeyboardInterrupt` → зовём `shutdown()` (и можно `stop()` для reader).

### 3) Обновить циклы

* В `self._reader_loop`: условие `while not self._reader_stop:`
* В `self._rep_loop`: **не** завязываемся на флаг чтения. Либо `while True:` и break только при `self._service_stop`, либо `while not self._service_stop:`.
  Так `stop_acquire` не убьёт REP-обработчик.

### 4) Ретюн без убийства REP

* В `retune_task()` (внутри обработки `set_sdr_config`) мы сейчас зовём `self.stop()` — это ок, если `stop()` больше **не** трогает REP. После пересоздания backend — `self.start()` как и было. (Оставляем.)

### 5) (Опционально) Чуть улучшить `stop()`

* После `join()` можно, если поток жив, логнуть warning, но **обязательно** отправлять ACK из REP немедленно (как уже делается). Никаких блокировок REP > ~1 сек.

---

## Псевдо-diff (куда вставить/переименовать)

```diff
 class BeaconDSPService:
   def __init__(...):
-    self._stop = False
+    self._reader_stop = False       # управляет только reader_loop
+    self._service_stop = False      # управляет только жизнью REP/PUB сервиса

   def start(self):
-    with self._lock:
-        if self.reader_thread and self.reader_thread.is_alive():
+    with self._lock:
+        if self.reader_thread and self.reader_thread.is_alive():
             ...
-        self._stop = False
+        self._reader_stop = False
         self._acq_state = AcqState.RUNNING
         self.reader_thread = threading.Thread(target=self._reader_loop, daemon=True)
         self.reader_thread.start()

   def stop(self):
-    thread_to_stop = None
+    thread_to_stop = None
     with self._lock:
-        if not self.reader_thread or not self.reader_thread.is_alive():
+        if not self.reader_thread or not self.reader_thread.is_alive():
             self._acq_state = AcqState.STOPPED
             return
-        self._stop = True
+        self._reader_stop = True
         self._acq_state = AcqState.STOPPED
         thread_to_stop = self.reader_thread
     if thread_to_stop:
         thread_to_stop.join(timeout=1.0)
     if self.jsonl_fp:
         self.jsonl_fp.flush()

+  def shutdown(self):
+      # Корректное завершение всего сервиса (используется в __main__)
+      with self._lock:
+          self._service_stop = True
+      try:
+          self.stop()  # останавливаем только reader
+      except Exception:
+          pass
+      try:
+          if self.rep: self.rep.close(0)
+          if self.pub: self.pub.close(0)
+          if self.ctx: self.ctx.term()
+      except Exception:
+          pass
+      try:
+          self._executor.shutdown(wait=False, cancel_futures=True)
+      except Exception:
+          pass

   def _reader_loop(self):
-    while not self._stop:
+    while not self._reader_stop:
         ...

   def _rep_loop(self):
-    while not self._stop:
+    while not self._service_stop:
         try:
             msg = self.rep.recv_json(flags=0)
         except Exception:
             time.sleep(0.01)
             continue
         ...
```

Этих правок достаточно, чтобы **`stop_acquire` больше не уничтожал REP-цикл**, а кнопки не «умирали» после первого стопа. Остальной «анти-вис» (мгновенный ACK, воркер для тяжёлых задач и т.д.) у вас уже реализован — они будут работать стабильно после разведения флагов. 

---

## Как быстро перепроверить

1. Перезапустить сервис:

```powershell
python beacon_dsp_service.py --pub tcp://127.0.0.1:8781 --rep tcp://127.0.0.1:8782
```

2. Прогнать тот же смок:

```powershell
python test_service_auto_file_switch.py --addr tcp://127.0.0.1:8782 --loops 2 --file C:/work/TesterSDR/captures/psk406msg_f100.cf32
```

Ожидаем:

* `Echo` OK.
* `AUTO` готов, первый `start/stop` OK.
* Второй `start/stop` — **без** таймаутов (REP жив).
* Переключение `file` — ACK сразу; после «ретюна» статус `file/ready`.
* `start/stop` на `file` — тоже без таймаутов.
* SPAM-тест (10×) — все 20 команд (start/stop) отвечают ACK; 0/20 таймаутов. 

