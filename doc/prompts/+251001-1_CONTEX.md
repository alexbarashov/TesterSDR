# ТЗ: «Анти-вис» для DSP-сервиса и кнопок UI

## 0) Цель

Сделать взаимодействие UI↔DSP надёжным: **каждый запрос мгновенно получает ответ (ACK)**, долгие операции выполняются асинхронно, **кнопки Start/Stop/SetConfig/Save** не приводят к зависанию и несогласованности состояния.

---

## 1) Обязательные изменения в `beacon_dsp_service.py`

### 1.1 REP-обработчик команд (ZeroMQ)

* **Мгновенный ACK** для всех команд: `{"ok": true, ...}` должен возвращаться **до** долгих операций.
* **Асинхронность**: тяжёлые действия (создание/закрытие backend, перетюнинг) — в отдельном воркере (thread), **REP-поток не блокируем**.
* **idempotency**: повторные одинаковые команды не должны ронять состояние и повторно не создавать ресурсы.
* **Единая схема ошибок**: `{"ok": false, "error": "<code|human-readable>"}`. Без молчаливых таймаутов.

#### Новые/уточнённые команды:

* `"echo"` — эхо-ответ для быстрой проверки канала: вернуть `{"ok": true, "echo": <payload>}`. (Это нужно смок-тестеру.) 
* `"start_acquire"` — если уже идёт, вернуть `ok` + `{"acq_state":"running"}` без побочных эффектов.
* `"stop_acquire"` — если уже остановлен, вернуть `ok` + `{"acq_state":"stopped"}`.
* `"get_status"` — расширить полезную нагрузку (см. 1.2).
* `"set_sdr_config"` — **сразу ACK** c `{"backend_changed": bool, "retuned": bool}` и перенос тяжёлой части в воркер. Во время пересоздания backend состояние должно переходить через `acq_state: "retuning"` и затем в `"ready"`/`"running"`.
* `"get_last_pulse"` — уже есть; убедиться, что всегда отвечает (даже если данных нет).
* `"save_sigmf"` — мгновенный ACK + if no data → `{"ok": false, "error":"no_segment"}` (без зависаний).

### 1.2 Расширить статус (возвращается и в `status`-PUB, и в `get_status`-REP)

Добавить поля, которые ожидает UI/тестер:

```json
{
  "backend": "<auto|soapy_rtl|soapy_hackrf|...|file|file_wait>",
  "backend_args": "<строка пути или краткое описание>",
  "acq_state": "<stopped|running|retuning|ready>",
  "ready": true/false,                     // удобный флаг для UI
  "fs": <float>,                           // уже есть
  "bb_shift_hz": <float>,                  // уже есть (эффективный)
  "thresh_dbm": <float>,                   // уже есть
  "read_chunk": <int>,                     // уже есть
  "queue_depth": <int>,                    // уже есть
  "t_s": [...], "last_rms_dbm": [...]      // уже есть downsample ≤1000 точек
}
```

* В файловом режиме — **жёстко `bb_shift_enable=false` и `bb_shift_hz=0.0`** и это отражаем в статусе (у вас частично сделано, закрепить как инвариант). 
* В режиме «ожидания файла» (fallback) отчётливо указывать `backend:"file_wait"`, `ready:false`.

### 1.3 Менеджмент потоков и состояния

* Ввести **один `acq_state` (строка)** и защищённый мьютексом контекст:

  * `"stopped"` — чтение не идёт;
  * `"running"` — основной loop активен;
  * `"retuning"` — короткая фаза пересоздания backend;
  * `"ready"` — backend инициализирован, можно `start`.
* `start()`/`stop()` сделать **идемпотентными**: повторный вызов не меняет логику, всегда `ok`.
* Все поля, читаемые UI/REP, менять **только под локом**.

### 1.4 Дедупликация и защита REP

* REP-поток **всегда** отвечает, даже при исключениях.
* Любая неизвестная команда: `{"ok": false, "error":"unknown_cmd"}` (сейчас близко, оставить и привести к единому ключу). 
* ZMQ-сокеты создавать один раз; при исключениях не «терять» REP-сокет.

### 1.5 Разграничить «мгновенные» и «тяжёлые» операции

* Мгновенные: echo, get_status, start/stop (если состояние не меняется), get_last_pulse.
* Тяжёлые: set_sdr_config (замена backend), save_sigmf (запись в файл) — **но**: запись небольшого сегмента ≤10–50 МБ делать в воркере, а ответ с путём файла присылать **после завершения** через событие PUB (`{"type":"file_saved", ...}`) и/или отдельную команду `"await_last_save"` по запросу. (Если нужно строго оставить синхронным — ставим тайм-лимит и даём `ok`/`error` в рамках этого лимита.)

---

## 2) Анти-вис логика «кнопок» UI

### 2.1 Протокол для UI

* UI **посылает команду** → **сразу получает ACK** (Это главное: **никаких ожиданий внутри REP**).
* UI **не** делает повторный запрос, пока не получил ответ по предыдущему (REQ/REP lockstep).
* Для визуального статуса UI периодически опрашивает `get_status` (или подписывается на PUB).

### 2.2 Дребезг кнопок (anti-spam)

* В сервисе реализовать **внутренний «in-flight» флаг** для операций, меняющих backend/state, и возвращать `{"ok": true, "info":"busy"}` без падения и блокировки.
* Тест на «нажатие 10× подряд» (см. смок-скрипт). 

---

## 3) Тест-план (смок + сценарии регрессии)

### 3.1 Смок-скрипт (готовый)

Использовать ваш `test_service_auto_file_switch.py`:

1. Запустить сервис:

```bash
python beacon_dsp_service.py --pub tcp://127.0.0.1:8781 --rep tcp://127.0.0.1:8782
```

2. В другом терминале:

```bash
python test_service_auto_file_switch.py --addr tcp://127.0.0.1:8782 --loops 2 --file C:/work/TesterSDR/captures/psk406msg_f100.cf32
```

**Ожидаемо**:

* `echo` отвечает мгновенно;
* `set_sdr_config:auto` → `ok` и далее `poll_ready` видит `backend:"auto"` и `ready:true`;
* `start/stop` циклы 2× на `auto` проходят без ошибок;
* `set_sdr_config:file` с путём → `ok`, `poll_ready` видит `backend:"file"` и `ready:true`;
* быстрый «спам» start/stop 10× проходит без таймаутов и без смены `acq_state` на невалидные значения. 

### 3.2 Негативные сценарии

* `set_sdr_config:file` с **пустым** путём → `ok`, но статус `backend:"file_wait"`, `ready:false`; **кнопки не висят**, `get_status` живой.
* `start_acquire` при `backend:"file_wait"` → `ok`, `acq_state` остаётся `stopped`, сервис жив.
* Быстрые подряд `set_sdr_config` на разные backends → ни одного зависания REP; в процессе статусы переходят `retuning → ready`.

### 3.3 Регрессии по данным

* В файловом режиме `bb_shift_enable=false`, `bb_shift_hz=0.0` **всегда** (и в статусе тоже). 
* `get_last_pulse` отвечает даже если данных ещё нет (`ok:false, error:"No pulse data available"` — как сейчас, но без таймаута). 

---

## 4) Логи и наблюдаемость

* При старте сервиса **одной строкой печатаем текущий уровень логирования** и ключевые параметры (backend, fs, bb_shift, thresholds).
* Для каждой REP-команды — **строка-трекер**: `cmd=<...> ack=<dt_ms>`; для тяжёлых — ещё и `done=<dt_ms>` (в воркере).
* Ограничить спам-лог: не печатать гигабайты, только агрегаты и события.

---

## 5) Структура кода (кратко)

* Ввести небольшой **JobRunner/Executor** (один `ThreadPoolExecutor` или свой воркер-тред с очередью) для тяжёлых задач.
* REP-loop: парсинг, валидация, **мгновенный ответ**, enqueuing тяжёлой работы → воркер обновляет состояние и эмитит PUB-событие `{"type":"retune_done"/"file_saved"/...}`.

---

## 6) Критерии приёмки

1. Никакая из команд **никогда** не приводит к подвисанию REP-ответа.
2. Смок-скрипт полностью проходит **без** `recv timeout` и без «рассинхронизации» REQ/REP. 
3. В файловом режиме BB-shift **всегда отключён** и отражён в статусе. 
4. Быстрые сериалы `start/stop` (≥10×) завершатся без ошибок; состояние в конце корректное (`stopped`).
5. Переключение `auto → file → auto` многократно не приводит к зомби-тредам и утечкам; `acq_state` проходит через `retuning` и возвращается в `ready/running`.
6. UI-кнопки перестают «виснуть» — каждое действие мгновенно отражается: либо `ok`, либо понятная `error`.

---
