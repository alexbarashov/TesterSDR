# ТЗ: команда `set_sdr_config` + устойчивость REQ/REP

## Цели

1. В `beacon_dsp_service.py` реализовать **команду `set_sdr_config`** с мгновенным ACK и асинхронным применением (переключение бэкенда не блокирует REP-цикл).
2. Принудительно отключать **BB-shift в режиме `file`**.
3. Гарантировать, что быстрые клики **Start/Stop** не ломают REQ/REP-синхронизацию и не вешают UI.
4. Проверить всё готовым скриптом-тестером (уже использует `set_sdr_config` и «спам-клики»). 

---

## 1) Протокол команд (REQ → REP)

### Новая команда: `set_sdr_config`

**Запрос (пример):**

```json
{
  "cmd": "set_sdr_config",
  "backend": "file",               // "auto" | "file" | "soapy_rtl" | "soapy_hackrf" | ...
  "backend_args": {"path":"C:/work/TesterSDR/captures/psk406msg_f100.cf32"},
  "bb_shift_enable": false,        // игнорировать и форсить false при backend="file"
  "bb_shift_hz": 0.0
}
```

**Ответ (мгновенный ACK):**

```json
{
  "ok": true,
  "accepted": {
    "backend_name": "file",
    "backend_args": {"path":"..."},
    "bb_shift_enable": false,
    "bb_shift_hz": 0.0
  }
}
```

**Требования реализации:**

* В REP-цикле ( `_rep_loop` ) добавить обработчик `elif cmd == "set_sdr_config":`

  * Считать поля, **сразу** отправить ACK (`rep.send_json(...)`) — не блокировать.
  * В отдельном воркере (через существующий executor) выполнить:

    1. `stop()` текущего бекэнда (если нужно).
    2. Обновить `self.backend_name`, `self.backend_args`.
    3. Если `backend_name == "file"` → `self.effective_bb_shift_enable = False; self.effective_bb_shift_hz = 0.0`.
       Для остальных — взять из запроса.
    4. Пересоздать бэкенд (`self._make_backend()`), затем `start()` если это ожидаемое поведение.
    5. Корректно обновить `self._acq_state` (RETUNING → READY/ RUNNING) и **вызвать `_emit_status()`**.

* Состояния:
  `IDLE/READY/RUNNING/RETUNING`. Во время применения — `RETUNING`, после — `READY` (или `RUNNING`, если автозапуск).

* Команды `start_acquire`/`stop_acquire` должны быть **идемпотентными**: повторный `start` при RUNNING и `stop` при STOPPED дают `{ok:true}` без ошибок.

* `get_status` должен возвращать поля, используемые UI (примерные):
  `backend`, `ready`, `acq_state`, `bb_shift_enable`, `bb_shift_hz`, `t_s`, `last_rms_dbm`, и т.п. (как у вас уже заведено в `_emit_status()`).

---

## 2) PUB-уведомления (как есть)

* При смене состояния и новых данных — продолжать публиковать статус/события через PUB (порт без изменений).
* Ничего особенного добавлять не нужно — главное, чтобы `_emit_status()` вызывался после ретюна.

---

## 3) Логирование

* Логировать время ACK: `cmd=set_sdr_config ack=...ms accepted=...`.
* Ошибки пересоздания бекэнда — в `log.error(...)`, но без падений REP-цикла.
* При старте сервиса один раз печатать активный уровень логирования.

---

## 4) Тест-план (скрипт уже готов)

Используем `test_service_auto_file_switch.py`:

**Базовые шаги:**

1. Запуск сервиса (как обычно).
2. В отдельной консоли:

   ```bash
   python test_service_auto_file_switch.py --addr tcp://127.0.0.1:8782 --loops 2 --file C:/work/TesterSDR/captures/psk406msg_f100.cf32
   ```

   Скрипт делает:

   * `echo` (опционально, не строго)
   * `get_status`
   * `set_sdr_config:auto` → ждёт готовность (poll_ready)
   * `start/stop` по циклу на auto
   * `set_sdr_config:file` → ждёт готовность `backend=file` (poll_ready)
   * `start/stop` по циклу на file
   * **spam-тест**: чередует `start/stop` 10 раз (REQ/REP должен оставаться в такте, без таймаутов). 

**Ожидаемые признаки успеха:**

* На `set_sdr_config:*` всегда мгновенный `{"ok":true}` в десятки миллисекунд.
* Во время применения — статусы показывают `acq_state=retuning`, затем `ready=true` и правильный `backend`.
* В режиме `file` в статусе — `bb_shift_enable=false`, `bb_shift_hz=0.0`.
* Все `start/stop` и «spam-клики» завершаются без таймаутов и ошибок.
* В `beacon_dsp2plot.py` первая панель (RMS) оживает сразу после `start`, вторая панель строит пульс по событию (как раньше).

---

## 5) Контрольные чек-листы для ревью

* [ ] В `_rep_loop` есть ветка `set_sdr_config` с **немедленным ACK**.
* [ ] Применение настроек вынесено в executor-задачу; REP-цикл не блокируется.
* [ ] В `file`-режиме **BB-shift принудительно OFF**.
* [ ] `start/stop` устойчивы к быстрым повторным кликам (идемпотентны).
* [ ] `_emit_status()` вызывается по окончании ретюна.
* [ ] Тест-скрипт проходит все этапы, включая spam-секцию. 

---

## 6) Подсказка по реализации (скелет обработчика)

> Вставить в `_rep_loop` рядом с остальными `elif cmd == ...`:

```python
elif cmd == "set_sdr_config":
    desired_backend = str(msg.get("backend", self.backend_name or "auto"))
    desired_args = msg.get("backend_args", self.backend_args)
    bb_en = bool(msg.get("bb_shift_enable", self.effective_bb_shift_enable))
    bb_hz = float(msg.get("bb_shift_hz", self.effective_bb_shift_hz))

    # мгновенный ACK
    accepted = {
        "backend_name": desired_backend,
        "backend_args": desired_args,
        "bb_shift_enable": False if desired_backend == "file" else bb_en,
        "bb_shift_hz": 0.0 if desired_backend == "file" else bb_hz,
    }
    self.rep.send_json({"ok": True, "accepted": accepted})

    def _apply():
        with self._lock:
            self._acq_state = AcqState.RETUNING
        try:
            self.stop()
            args = desired_args
            if isinstance(args, str):
                args = {"path": args}
            self.backend_name = desired_backend
            self.backend_args = args
            if desired_backend == "file":
                self.effective_bb_shift_enable = False
                self.effective_bb_shift_hz = 0.0
            else:
                self.effective_bb_shift_enable = bb_en
                self.effective_bb_shift_hz = bb_hz
            self._make_backend()
            if self.backend:
                self.start()
        except Exception as e:
            log.error(f"set_sdr_config apply failed: {e}")
        finally:
            with self._lock:
                if self._acq_state != AcqState.RUNNING:
                    self._acq_state = AcqState.READY
            self._emit_status()

    self._executor.submit(_apply)
```
