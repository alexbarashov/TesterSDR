
# ТЗ: Рендер «FM In-burst» c min/max-по-пикселю и экономией трафика (≤2000 точек)

## Цель

На крупных масштабах (10×…100×) пики «сминаются» из-за усреднения. Нужно рисовать **истинную амплитуду** коротких импульсов с помощью **min/max-по-пикселю** и ограничить объём данных, передаваемых по HTTP, **не более 2000 точек за запрос** (лучше меньше на мелких окнах).

## Ограничения (STRICT_COMPAT)

* Ничего не ломаем в существующих эндпойнтах и UI; всё — **аддитивно**.
* Включение нового режима — только для вида **“406 inburst fr” / FM-график** (без вмешательства в другие режимы).
* Обновление по таймеру как сейчас (≈1 Гц).

---

## Что сделать

### 1) Сервер: выделенная выборка min/max (LOD)

Добавить эндпойнт (название любое):

```
GET /api/fm_minmax?scale=<percent>&width_px=<W>
```

**Вход:**

* `scale` — текущий масштаб времени в процентах (1, 2, 5, 10, …, 100).
* `width_px` — реальная ширина канваса (кол-во столбцов/пикселей графика).

**Логика на сервере:**

1. Определить диапазон видимых сэмплов `N_vis` по `scale`.
2. Выбрать целевое число столбцов `C`:

   * `C = min(width_px, 1000)` — верхняя граница колонок для рисования (≈ ширина).
   * Общий лимит точек: `2*C ≤ 2000`.
     (2 — потому что на колонку отдаём **min и max**.)
3. Расчёт «бакетов»: `bucket = ceil(N_vis / C)`.
4. Для каждого бакета вычислить `y_min, y_max` (по FM-ряду; если нет — другой ряд девиации).
5. Возвращать данные **без массива X**:

   * `x0` — стартовое время (мс) видимого окна,
   * `dt` — шаг по времени внутри одной колонки (мс) = `bucket / fs * 1000`,
   * `y_min[]`, `y_max[]` длиной `C`.
6. Квантовать значения для экономии трафика:

   * округление `y` до **0.1 Гц** (или до 1 Гц, если диапазон большой),
   * `x0, dt` — до **0.1 мс**.
7. Жёсткий лимит: если `2*C > 2000`, уменьшить `C` пропорционально, чтобы `2*C ≤ 2000`.

**Ответ JSON (пример):**

```json
{
  "x0_ms": 156000.0,
  "dt_ms": 1.25,
  "y_min": [ -12.3, -11.7, ... ],
  "y_max": [  0.8,   9.4, ... ],
  "fs_sps": 1024000,
  "visible_len": 123456,
  "bucket": 128
}
```

> Опционально (на будущее): LOD-пирамида (min/max для окон 2,4,8,…). Если успеваешь — делай предрасчёт при поступлении нового буфера; если нет — делаем «на лету» (один проход по окну).

### 2) Клиент: отрисовщик min/max

В файле фронта, в ветке вида **inburst_fr / FM**:

* добавить функцию `drawInburstFMMinMax(data)`:

  * на вход — JSON из `/api/fm_minmax`,
  * рисовать **вертикальные отрезки** на каждой колонке: `y_min..y_max` (одним `LineCollection` / серией `vlines` / path),
  * шкала Y — как в текущем FM-графике (±10 кГц, сетка не меняется),
  * подпись «Fig.10 Inburst Frequency (min/max)».
* в логике обновления для этого вида вызывать новый эндпойнт и отрисовщик.
* если `scale` настолько маленький, что `N_vis ≤ 2000`, можно (простое правило):

  * либо продолжать min/max-режим (ок, будет ровно),
  * либо (по желанию) запросить «сырые» точки старым эндпойнтом — но **только если** их ≤2000.
    **Просто и надёжно:** всегда рисовать min/max — и не усложнять.

### 3) Сетевой бюджет

* Гарантировать ≤2000 чисел на ответ (фактически 2*C, где C ≤ 1000).
* Обновление не чаще 1 Гц.
* Не передавать массив X, использовать `x0_ms + i*dt_ms`.
* Числа в JSON — короткие (округление, без избыточных знаков).

---

## Критерии приёмки

1. **Амплитуда сохраняется**: узкие пики на масштабе 10×…100× видны с той же высотой, что и на мелком масштабе (без «смина»).
2. **Трафик ≤2000 точек** на запрос:

   * при `width_px = 1200` сервер отдаёт `C=1000` колонок → `2000` значений (min+max).
   * при меньших ширинах — пропорционально меньше.
3. **FPS ≥ 20** на клиенте при отрисовке 1000 вертикальных «иголок» (одним батчем).
4. Масштаб 1–5% визуально совпадает с текущим (без деградации).
5. Переход между масштабами не вызывает скачков оси Y и «дрожания» линии.

---

## Псевдокод (сервер, выборка)

```python
def fm_minmax(scale_pct, width_px, fm_array, fs):
    N = len(fm_array)
    frac = clamp(scale_pct/100.0, 0.01, 1.0)
    N_vis = max(1, int(N * frac))          # сколько сэмплов попадает в окно
    # центр или текущий фокус — как в приложении (упростим):
    i0 = max(0, (N - N_vis)//2); i1 = i0 + N_vis

    C = min(width_px, 1000)                # кол-во колонок
    while 2*C > 2000:
        C = C//2 if C > 1 else 1

    bucket = math.ceil(N_vis / C)
    y_min = []; y_max = []

    for c in range(C):
        a = i0 + c*bucket
        b = min(i1, a + bucket)
        if a >= b: break
        block = fm_array[a:b]
        mn = float(np.min(block))
        mx = float(np.max(block))
        y_min.append(round(mn, 1))         # квантуем 0.1 Гц
        y_max.append(round(mx, 1))

    dt_ms = (bucket / fs) * 1000.0
    x0_ms = (i0 / fs) * 1000.0
    return { "x0_ms": round(x0_ms, 1),
             "dt_ms": round(dt_ms, 3),
             "y_min": y_min,
             "y_max": y_max,
             "fs_sps": fs,
             "visible_len": N_vis,
             "bucket": bucket }
```

---

## Нужные точки интеграции

* Сервер: рядом с текущими API (`/api/state`, `/api/last_pulse`) добавить `/api/fm_minmax`.
* Клиент: в обработчике вида **inburst_fr**:

  * на `onTimeScaleChange()` перезапрашивать `/api/fm_minmax?scale=...&width_px=...`,
  * рисовать через новый рендер «вертикальных иголок».

