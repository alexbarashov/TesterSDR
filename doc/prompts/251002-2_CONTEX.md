# ТЗ: починить второе окно в `_dsp2plot`

## 0) Цель

Сделать так, чтобы второе окно стабильно показывало:

* верхний график **RMS, dBm**,
* середний **Фаза, rad**,
* нижний **FM, Hz**,
  и чтобы по кнопке **«Параметры»** выводилась таблица фазовых метрик для последнего импульса.

---

## 1) Стабильная подача данных в графики (исправить поток)

**Проблема:** сейчас данные обновляются прямо из SUB-потока в `_on_pulse_event`, а `matplotlib` не потокобезопасен — из-за этого линии во втором окне могут не перерисовываться.

**Сделать:**

1. В `__init__` создать неблокирующую очередь, например:

   ```python
   import queue
   self._pulse_q = queue.Queue(maxsize=2)
   ```
2. В `_on_pulse_event`:

   * не трогать оси/линии напрямую;
   * собрать «снимок» полей события:
     `phase_xs_ms`, `phase_ys_rad`, `fr_xs_ms`, `fr_ys_hz`, `rms_ms_dbm`, а также `iq_seg`, `core_gate`, `phase_metrics`, `msg_hex`;
   * положить этот dict в `self._pulse_q` (очистив очередь, если полна).
3. В `_poll_status` (который и так тикает на **главном** UI-потоке) добавить секцию «дочитать последнее pulse-событие из очереди» и **только там** обновлять `self.ln_pulse/ln_phase/ln_fm` + `axes.set_xlim/ylim` + `fig2.canvas.draw_idle()`.

> Это устранит гонки потоков и вернёт отрисовку RMS/FM/Фазы.

---

## 2) Нормализовать схему события `pulse` (сообщения от сервиса)

**Проблема:** могло приехать событие другого формата/имен полей — графики остаются пустыми.

**Сделать (минимальный контракт):**
Сервис обязан публиковать события вида:

```json
{
  "type": "pulse",
  "phase_xs_ms": [ .. ],   // X (мс) для фазы
  "phase_ys_rad": [ .. ],  // Y (рад) для фазы
  "fr_xs_ms":     [ .. ],  // X (мс) для FM
  "fr_ys_hz":     [ .. ],  // Y (Гц) для FM
  "rms_ms_dbm":   [ .. ],  // Y (дБм) для RMS (тот же X, что и phase_xs_ms)
  "phase_metrics": { .. }, // снапшот метрик (см. §3)
  "msg_hex": "…",          // если есть
  "iq_seg": [ .. ],        // комплексный сегмент (float32 complex), если есть
  "core_gate": [i0, i1]    // ядро для спектра, если есть
}
```

Если длины массивов расходятся — принимать только согласованные пары (X/Y одинаковой длины), иначе мягко логировать «schema mismatch» и не падать.

> В `beacon_dsp2plot.py` уже ожидаются эти ключи — просто сделайте их обязательными на стороне сервиса/транслятора. 

---

## 3) «Параметры» — источник и fallback-расчёт

**Проблема:** окно «Параметры» пустое, когда `phase_metrics` нет.

**Сделать:**

1. **Основной путь (предпочтительно):** сервис заполняет `phase_metrics` готовыми значениями (по вашему уже принятым формулам проекта: Pos/Neg, Rise/Fall по уровням ±0.88 рад, Asymmetry по τ1/τ2, Fmod, Power…). UI просто показывает таблицу. (Кнопка **«Параметры»** уже умеет отображать снапшот.) 
2. **Временный fallback (на стороне UI):** если `phase_metrics` отсутствует, но есть `phase_xs_ms/phase_ys_rad`:

   * Pos, Neg: медианы по «плато» > +0.6 рад и < –0.6 рад (если есть).
   * Rise/Fall (μs): найти первый переход по порогам –0.88 → +0.88 (и наоборот), интерполировать по X(ms) ×1000.
   * Asymmetry (%): оценить τ1/τ2 как половинки двух соседних битов (по сменам знака), формула |τ1−τ2|/((τ1+τ2)/2)×100.
   * Fmod (Hz): 1/(средняя длительность полубита в сек).
   * Power (RMS, dBm): медиана массива `rms_ms_dbm` (если есть).
   * HEX: `msg_hex` (если есть).
     Эти оценки пометить в заголовке таблицы как «approx».

---

## 4) Обновление линий и осей во втором окне

В коде, который будет выполняться **на главном потоке** (см. §1.3), для каждого набора:

* **RMS**: `ln_pulse.set_data(px, rms)`; `ax_pulse.set_xlim(px.min(), px.max())`; Y-диапазон = [min−2, max+2] dBm.
* **Фаза**: `ln_phase.set_data(px, py)`; `ax_phase.set_xlim(px.min(), px.max())`; `ax_phase.set_ylim(-1.5, +1.5)` (как и сейчас).
* **FM**: `ln_fm.set_data(fx, fy)`; `ax_fm.set_xlim(fx.min(), fx.max())`; Y-диапазон авто: [min−50, max+50] Гц.

После обновления любого из графиков — `fig2.canvas.draw_idle()` (один раз на тик).

> Имена линий/осей уже есть: `ln_pulse/ax_pulse`, `ln_phase/ax_phase`, `ln_fm/ax_fm`. Просто перенести апдейты из `_on_pulse_event` в «главный» цикл. 

---

## 5) Диагностика и защита от «тихих» сбоев

Добавить мягкое логирование:

* в `_on_pulse_event`: печатать `received keys: …` при первых 3 событиях и при несоответствии схемы;
* в главном цикле при извлечении из очереди: если массивы пустые/разной длины — печатать короткое «skip: reason=…»;
* в «Параметры»: если всё равно нечего показать — выводить окно с явным сообщением «Нет параметров. Сначала должен быть обнаружен PSK импульс.» (оно уже есть; оставить). 

---

## 6) Критерии приёмки

1. При поступлении `pulse` событие с валидными массивами — во втором окне **одновременно** появляются кривые **RMS, Фаза, FM**, оси масштабируются по данным.
2. Кнопка **«Параметры»** показывает таблицу с числовыми значениями; при отсутствии `phase_metrics` — включается fallback-расчёт (таблица помечена «approx»).
3. Кнопка **«Сообщение»** показывает таблицу с полями при наличии `msg_hex`; при отсутствии — информативное окно.
4. При непрерывном потоке событий UI не «моргает» и не падает; при «Стоп» (тумблер второго окна) кривые замирают, но новые события продолжают приниматься в очередь, и после «Старт» графики обновляются свежими данными.
5. Нет подвисаний/исключений «from non-main thread» в трассах.

---

## 7) Тест-план (минимальный)

1. Запуск с `--autostart`, backend=`file`, файл с валидным импульсом.
2. Проверить, что в логах появляются `[cmd=get_status] ack=… ms → OK` и первые 1–3 события печатают `received keys`.
3. Убедиться, что во втором окне видны RMS/Фаза/FM. Сделать «Стоп» → поток идёт, графики не меняются; «Старт» → снова обновляются.
4. Нажать **«Параметры»** — таблица со значениями. Отсутствует `phase_metrics` → видна таблица «approx».
5. Нажать **«Сообщение»** — таблица с разбором или понятный текст при отсутствии.
6. Нажать **«Спектр»** — строится спектр ядра (если есть `iq_seg` + `core_gate`), иначе печать «нет данных» (без исключений).

---

## 8) Что менять в коде (якоря)

* `Dsp2PlotUI.__init__`: завести `self._pulse_q`.
* `DspServiceClient.subscribe_events`/`_on_pulse_event`: собирать снимок события и класть в очередь; убрать прямой апдейт линий/осей.
* `Dsp2PlotUI._poll_status`: читать последний элемент из очереди и **здесь** обновлять линии/оси фигуры 2.
* `Dsp2PlotUI._on_show_params`: добавить вызов fallback-калькулятора, если `self.last_phase_metrics` пуст.
* (Опционально) Включить один раз «печать схемы» по первым событиям для отладки.


