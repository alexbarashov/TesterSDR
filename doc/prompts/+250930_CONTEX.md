
# ТЗ: режим File в связке `dsp2plot` ↔ `dsp_service`

## 0) Диагноз (почему «тишина» после `set_sdr_config`)

* **Сервис пересоздаёт backend некорректно:** вызов `safe_make_backend(...)` с неверными именами/порядком аргументов, не обновляет свои поля, не стартует чтение — в итоге Reader остаётся в `file_wait` и не публикует события. 
* **UI берёт `fs`/поля из `get_status` не из вложенного `status` объекта** — стартовые шкалы/порог инициализируются неверно (потом это тянет цепочку пустых лимитов и т.п.). 
* **REP `get_status` сервиса не возвращает `t_s/last_rms_dbm`**, хотя PUB-событие `status` уже публикует эти поля. UI рассчитывает на них для верхнего графика «Sliding RMS». 

---

## 1) `beacon_dsp_service.py` — правки backend-переключения и статуса  

### 1.1 `set_sdr_config` (ветка REP)

**Задача:** при смене `backend_name`/`backend_args` реально пересоздавать backend с корректными параметрами, обновлять поля сервиса и перезапускать чтение.

**Сделать:**

* Поддержать оба формата входа:

  * предпочтительный: `msg["config"]`
  * совместимость: плоские ключи (кроме `cmd`)
* Нормализовать `backend_args`:

  * если пришла строка → `{"path": "<строка>"}` (хранить как строку в device_args допустимо, но лучше dict с ключом `path`)
* Сравнить `(old_backend_name, old_backend_args)` с `(new_backend_name, new_backend_args)`:

  * если отличаются → `backend_changed = True`

    1. `self.stop()`
    2. если `self.backend`: `self.backend.close()` и обнулить
    3. правильный вызов **`safe_make_backend`** (ключи как в инициализации сервиса):

       ```python
       self.backend = safe_make_backend(
           name = actual_backend,                      # "file"/"soapy_*"/"rsa306"/etc
           sample_rate = SAMPLE_RATE_SPS,
           center_freq = CENTER_FREQ_HZ,
           gain_db = TUNER_GAIN_DB if USE_MANUAL_GAIN else None,
           agc = ENABLE_AGC,
           corr_ppm = FREQ_CORR_PPM,
           device_args = new_backend_args,             # dict | {"path": "..."} | str
           if_offset_hz = IF_OFFSET_HZ,
           on_fail = "file_wait"
       )
       ```

       > В текущем коде путаются позиционные/именные аргументы и имя параметра `gain` vs `gain_db` → backend создаётся неверно. Исправить на вариант выше.
    4. Обновить параметры сервиса от backend:

       ```python
       st = self.backend.get_status() or {}
       self.sample_rate = float(st.get("actual_sample_rate_sps",
                        getattr(self.backend, "actual_sample_rate_sps", SAMPLE_RATE_SPS)))
       self.win_samps = max(1, int(round(self.sample_rate * (RMS_WIN_MS * 1e-3))))
       self.nco_k = 2.0*np.pi*(BB_SHIFT_HZ/float(self.sample_rate))
       self.backend_name = new_backend_name
       self.backend_args = new_backend_args
       ```
    5. **Принудительно отключать BB-shift в файловом режиме:**

       ```python
       if actual_backend == "file":
           self.effective_bb_shift_enable = False
           self.effective_bb_shift_hz = 0.0
       else:
           self.effective_bb_shift_enable = bool(config.get("bb_shift_enable", BB_SHIFT_ENABLE))
           self.effective_bb_shift_hz = float(config.get("bb_shift_hz", BB_SHIFT_HZ))
       ```
    6. `self.start()` и вернуть `{"ok": True, "applied": {...}, "retuned": True}`
* Параметры, не требующие пересоздания (gain, freq_corr) применять только если `hasattr(self.backend, ...)` с корректными именами сеттеров.

### 1.2 REP `get_status` — добавить поля для UI

* В ответе REP (а не только в PUB) включать `t_s` и `last_rms_dbm` (с тем же даунсэмплом ≤1000), как делается в `_emit_status()`:

  ```python
  self.rep.send_json({"ok": True, "status": {
      "sdr": ...,
      "fs": float(self.sample_rate),
      "bb_shift_hz": float(self.effective_bb_shift_hz),
      "target_signal_hz": float(TARGET_SIGNAL_HZ),
      "thresh_dbm": float(PULSE_THRESH_DBM),
      "read_chunk": int(READ_CHUNK),
      "queue_depth": len(self.pulse_queue),
      "t_s": <list>,
      "last_rms_dbm": <list>
  }})
  ```

  Сейчас REP-ветка отдаёт только базовый `Status(...)` без историй — дополнить. 

---

## 2) `beacon_dsp2plot.py` — инициализация и парсинг `get_status`  

### 2.1 Первичный статус

* После `st = self.client.get_status()` UI должен читать вложенность:

  ```python
  if isinstance(st, dict):
      st_payload = st.get("status", st)
      self.last_status = st_payload
      self.sample_rate = float(st_payload.get("fs", self.sample_rate))
  ```

  Сейчас код берёт поля у корня `st.get("fs")` — поправить, иначе стартовые лимиты шкал неверные → «пустые» оси.

### 2.2 Логика после выбора файла (уже близко к норме)

* Оставить порядок: `stop_acquire()` → `get_sdr_config()` → заполнить `cfg` → `set_sdr_config(config=cfg)` → короткая пауза → `start_acquire()`.
* Для file-режима шлём:

  ```python
  cfg["backend_name"] = "file"
  cfg["backend_args"] = {"path": path}
  cfg["bb_shift_enable"] = False
  cfg["bb_shift_hz"] = 0
  ```

  Это уже делается; проверить, что в логах есть `[set_sdr_config result] {"ok": true, "retuned": true, ...}`.

---

## 3) Контракт после правок (сводно)

* **REQ `set_sdr_config`**
  запрос: `{"cmd":"set_sdr_config","config":{"backend_name":"file","backend_args":{"path":"C:/.../file.cf32"},"bb_shift_enable":false,"bb_shift_hz":0}}`
  ответ: `{"ok":true,"applied":{...},"retuned":true}`
* **REP `get_status`**
  ответ: `{"ok":true,"status":{"fs":...,"bb_shift_hz":...,"thresh_dbm":...,"read_chunk":...,"queue_depth":...,"t_s":[...],"last_rms_dbm":[...]}}`
* **PUB `status`** — уже правильно публикует `t_s/last_rms_dbm` (оставить как есть).
* **PUB `pulse`** — уже включает `phase_*`, `fr_*`, `rms_ms_dbm` (оставить; проверка при воспроизведении файла).

---

## 4) Чек-лист приёмки

1. Запуск UI без SDR → окна появляются быстро, лог: `[auto] dsp_service is ready`.
2. Выбор `psk406msg_f150.cf32`:

   * UI-лог:

     ```
     [backend] stop_acquire {'ok': True}
     [set_sdr_config] backend=file, file=...
     [set_sdr_config result] {'ok': True, 'retuned': True, ...}
     [backend] start_acquire {'ok': True}
     ```
   * В течение 1–2 сек идут PUB `status` с непустыми `t_s/last_rms_dbm` → верхний график «оживает».
   * При наличии импульса из файла приходят `pulse` с `rms_ms_dbm/phase_*/fr_*` → три нижних графика заполняются.
3. `Статус SDR` показывает вложенный объект `status` с полями `t_s/last_rms_dbm`.
4. Повторное открытие другого файла — графики обновляются без зависаний.

---

## 5) Нерегрессии

* В файловом режиме **всегда** `effective_bb_shift_enable=False`, `effective_bb_shift_hz=0.0`.
* Даунсэмплы визуальных рядов ≤1000 точек.
* Не ломать существующий PUB-формат `status/pulse/psk`.

