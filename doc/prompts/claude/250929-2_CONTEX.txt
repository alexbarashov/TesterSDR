
# ТЗ: Перенос полного UI в `dsp2web` с сохранением дизайна из `beacon_tester_buf-ring_web`

## 0) Контекст и цель

Есть:

* **`beacon_dsp_service.py`** — headless DSP-сервис (ZeroMQ PUB/REP).
* **`beacon_tester_dsp2web.py`** — тонкий веб-клиент (REST/SSE + мост к DSP).
* **`beacon_tester_buf-ring_web.py`** — **полный** WebUI (разметка/стили/панели/графики), но с локальной DSP-логикой.

**Цель:** в `beacon_tester_dsp2web.py` внедрить **полный UI** (визуально и структурно как в `beacon_tester_buf-ring_web.py`) без локальной DSP-обработки; все данные/команды идут через `dsp_service` по уже существующим эндпоинтам `dsp2web`.

---

## 1) Объём работ (Scope)

1. Перенести **разметку, стили и JS-структуру** из `beacon_tester_buf-ring_web.py` в `beacon_tester_dsp2web.py`:

   * Левая панель (режимы/кнопки/параметры).
   * Правая часть: панели **RMS**, **Phase**, **FM**, **Message/Decode**, **History/Log**.
   * Сохранить визуальный стиль (классы, CSS).
2. **Не** переносить локальную DSP-логику/чтение файлов — только UI.
3. Подключить UI к REST/SSE `dsp2web`:

   * Команды → `/api/control/*`
   * Состояние/история → `/api/state`, `/api/last_pulse`
   * SSE → `/api/events` (status/pulse/psk/heartbeat)
   * Health → `/api/health`
4. Обновить JS-вызовы на тонкие REST/SSE (никаких прямых SDR вызовов).
5. Визуализация данных: использовать имеющиеся панели и рендеры (таблицы/мини-графики) из «полного UI», но заполнять данными из ответов API.

---

## 2) Функциональные требования

### 2.1 Кнопки/действия слева

* **Start** → `POST /api/control/start`
* **Stop** → `POST /api/control/stop`
* **Status** → `POST /api/control/get_status` (обновляет виджеты состояния)
* **Save SigMF** → `POST /api/control/save_sigmf` (показать уведомление об успехе/ошибке)
* **Apply Params** → `POST /api/control/params` с телом:

  ```json
  { "thresh_dbm": <float>, "rms_win_ms": <float> }
  ```
* Параметры (input’ы) в UI: `thresh_dbm`, `rms_win_ms` (остальные если были — оставить disabled/readonly для будущего).

### 2.2 Состояние/данные

* `GET /api/state` — отрисовать:

  * Индикацию соединения с DSP (зелёная/красная точка)
  * Текущие значения параметров (thresh_dbm, rms_win_ms)
  * Краткую сводку (например: счетчик пульсов, частота событий, время аптайма)
  * Ленту лога (если есть)
* `GET /api/last_pulse` — заполнить панели:

  * **RMS/Phase/FM** (минимальный набор: заголовки, численные метрики, мини-графики/спарклайны или табличные показатели — как в полном UI)
  * **Message/Decode** (если сервис присылает psk-блок/поля — вывести таблицей)
  * **History** (последние N событий — дата/время/тип/ключевые метрики)

### 2.3 Реал-тайм обновления (SSE)

Подписка: `EventSource('/api/events')`

* Событие `status`: компактно обновлять индикаторы состояния/метрик.
* Событие `pulse`: после прихода — вызвать `GET /api/last_pulse` и обновить правые панели.
* Событие `psk`: обновить секцию декодирования/таблицу сообщений.
* `heartbeat`: необязательное (можно использовать для «живости»).

### 2.4 Health

* `GET /api/health` — обновлять индикатор «Connected to DSP» каждые 5 с.

---

## 3) Нефункциональные требования

* **Без локальной DSP**: никакого чтения IQ/обработки в `dsp2web`.
* UI должен **не блокировать** основной поток (fetch + async).
* **Кроссбраузерно** для Chromium/Edge последних версий.
* Обновления UI не должны произвольно дёргать верстку (аккуратные перерисовки).
* Код в одном файле (как и было), но **чисто структурирован**:

  * `HTML_TEMPLATE` (или `HTML_PAGE`) — разметка+CSS
  * `<script>` — хелперы fetch/SSE, рендер-функции, инициализация

---

## 4) API-контракты (минимум)

> Примечание: Сервис уже реализован; опираемся на текущие поля. Если какого-то поля нет — UI выводит заглушку («—») без ошибок.

### 4.1 `/api/control/start|stop|get_status|save_sigmf|params`

* **Метод**: `POST`
* **Тело**:

  * `params`: как выше
  * Остальные: без тела
* **Ответ**: `{ "ok": true, ... }` + опциональные поля (`path`, `error`)

### 4.2 `/api/state`

* **Метод**: `GET`
* **Ответ (пример)**:

  ```json
  {
    "ok": true,
    "zmq_connected": true,
    "params": {"thresh_dbm": -25.0, "rms_win_ms": 5.0},
    "status": {"acquiring": true, "uptime_s": 1234},
    "last_pulse_meta": {"ts": "2025-09-29T06:20:15Z", "length_ms": 120.5},
    "log": ["..."]
  }
  ```

### 4.3 `/api/last_pulse`

* **Метод**: `GET`
* **Ответ (пример)**:

  ```json
  {
    "ok": true,
    "pulse": {
      "ts": "2025-09-29T06:20:15Z",
      "rms": {"peak_dbm": -23.1, "avg_dbm": -26.4},
      "phase": {"pos_rad": 1.08, "neg_rad": -1.10, "rise_us": 80.8, "fall_us": 79.9, "assym_pct": 3.1},
      "fm": {"max_hz": 700.0, "bw_hz": 2800.0},
      "psk": {"decoded": true, "proto": "C/S 406", "fields":[["MFR","..."],["SER","..."]]}
    },
    "history": [
      {"ts":"...","type":"pulse","peak_dbm":-24.3,"len_ms":121.0},
      {"ts":"...","type":"psk","decoded":true}
    ]
  }
  ```

### 4.4 `/api/events` (SSE)

* `status` → `{ "acquiring": true, "rms_dbm": -27.5, ... }`
* `pulse` → `{ "ts": "...", "length_ms": 120.5, ... }`
* `psk` → `{ "ts": "...", "decoded": true, ... }`
* `heartbeat` → `{}`

### 4.5 `/api/health`

* **Метод**: `GET`
* **Ответ**: `{ "ok": true, "zmq_connected": true }`

---

## 5) Изменения в коде (пошагово)

### 5.1 `beacon_tester_dsp2web.py`

1. Заменить текущий упрощённый шаблон на **полный** шаблон из `beacon_tester_buf-ring_web.py`:

   * Вырезать из «полного» все блоки, которые обращаются к локальной DSP/файлам.
   * Оставить разметку/стили/JS-каркас панелей.
   * Переименовать заголовок на «COSPAS/SARSAT Beacon Tester — DSP Client».
2. В `<script>`:

   * Добавить хелперы `post(url, data?)`, `get(url)`.
   * Реализовать функции:

     * `startAcquire()`, `stopAcquire()`, `getStatus()`, `saveSigMF()`, `setParams()`.
     * `refreshState()` → дергает `/api/state` и обновляет панель состояния.
     * `loadLastPulse()` → дергает `/api/last_pulse` и обновляет правые панели.
     * `startEventStream()` → подписка на `/api/events` + обработчики `status/pulse/psk/heartbeat`.
     * `checkHealth()` → `/api/health` → индикатор соединения.
     * Рендер-функции: `renderStatus`, `renderPulse`, `renderLiveStatus`, `onPulse`, `onPsk`, `updateConn`, `log`.
   * В `DOMContentLoaded`:

     ```js
     startEventStream();
     refreshState();
     loadLastPulse();
     checkHealth();
     setInterval(checkHealth, 5000);
     ```
3. Привязать кнопки UI к функциям (Start/Stop/Status/Save/Apply).

### 5.2 `beacon_dsp_service.py`

* **Без изменений.** (Контракт уже используется `dsp2web`.)

### 5.3 `beacon_tester_buf-ring_web.py`

* **Только источник шаблона/стилей.** Ничего править не нужно.

---

## 6) UX-детали

* Если данные отсутствуют, показывать нейтральные «—»/«no data yet».
* Для чисел — ограничивайте до разумной точности (напр., 1–2 знака).
* Для лог/истории — ограничить до N последних строк (напр., 200), автоскролл вниз.
* Индикация ошибок fetch (toast/алерт в лог) — без модальных блокировок.

---

## 7) Критерии приёмки (Acceptance)

1. Внешний вид и расположение панелей в `dsp2web` **совпадают** с полным UI.
2. `Start/Stop/Status/Save SigMF/Apply Params` корректно вызывают `/api/control/*`.
3. `SSE` события приходят; при `pulse` обновляется секция правых панелей.
4. `/api/state` и `/api/last_pulse` отображаются без ошибок, даже если часть полей отсутствует.
5. Health-индикатор корректно отражает доступность DSP.
6. Никаких обращений к локальной DSP/файлам внутри `dsp2web`.

---

## 8) Проверка/запуск (локально)

1. DSP-сервис:

   ```
   python beacon_dsp_service.py --pub tcp://127.0.0.1:8781 --rep tcp://127.0.0.1:8782
   ```
2. Веб-клиент:

   ```
   python beacon_tester_dsp2web.py --pub tcp://127.0.0.1:8781 --rep tcp://127.0.0.1:8782 --host 127.0.0.1 --port 8738
   ```
3. UI: открыть `http://127.0.0.1:8738/` и проверить сценарии из §7.

---

## 9) Ограничения и «вне зоны»

* Нет загрузки/сохранения IQ-файлов из UI.
* Нет изменений в протоколе ZeroMQ.
* Нет новых API-эндпоинтов (кроме JS-привязок и кнопки **Status** при необходимости).

---

## 10) Риски и меры

* **Несоответствие полей** в ответах сервиса → рендер-функции обязаны быть «терпимыми» (проверки `undefined`).
* **Долгая отрисовка графиков** → использовать мини-рендер (спарклайны/табличные метрики) и не строить тяжёлые графики на каждый тик SSE.

---

## 11) Чек-лист для PR

* [ ] В `dsp2web` появился **полный** HTML-шаблон и CSS из «полного UI».
* [ ] Все кнопки вызывают правильные REST-эндпоинты.
* [ ] SSE подключено; есть обработчики `status/pulse/psk/heartbeat`.
* [ ] Отрисовки не падают при пустых данных.
* [ ] Нет локальной DSP/файловых вызовов в `dsp2web`.
* [ ] Запуск по инструкциям из §8 работает, визуал совпадает.

---

