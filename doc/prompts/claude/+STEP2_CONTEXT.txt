Вот компактное ТЗ, которое можно **целиком скормить Claude в новом чате**.

---

# Задание (TesterSDR / Beacon Tester Web) — PSK-406 в реальном времени

**Режим:** STRICT_COMPAT (только точечные вставки, без смены API/архитектуры, без новых зависимостей).
**Файл фокуса:** `beacon_tester_web.py` (встроенный фронтенд можно править минимально — только JS-функции обновления).

## Контекст (что уже есть)

* Кольцевой буфер IQ ≥3 c, запись **после NCO**.
* Извлечение сегмента по абсолютным индексам.
* Везде используется `actual_sample_rate_sps` (через утилиту).
* API: `/api/init`, `/api/state`, `/api/last_pulse`.
* Frontend polling: обновление статуса раз в 1 с.

## Цель задачи (сегодня)

1. В `process_pulse_segment(...)` **интегрировать реал-тайм демодуляцию PSK-406** и вернуть ключевые метрики в API.
2. Добавить **историю импульсов** (deque на 50 шт.) и отдать её через `/api/last_pulse`.
3. Мини-расширение UI: в «Current» показать новые поля (битрейт, фазы, фронты, асимметрию, короткий HEX, CRC/OK).

## Требования к реализации

* Создать хелпер `analyze_psk406(iq_seg: np.ndarray, fs: float) -> dict` (без внешних зависимостей).

  * Внутри — **заглушка с try/except** и комментарии-якоря для вызова моих функций (я подключу позже):

    * `phase_demod_psk_msg_safe(...)` — получение сообщения и базовой статистики;
    * `calc_phase3_2(...)` — Pos/NegPhase, PhRise/Fall, Asymmetry (если доступно).
  * Возвращаемые поля (можно `None`, если пайплайн ещё не подключён):

    * `bitrate_bps`, `pos_phase`, `neg_phase`, `ph_rise_us`, `ph_fall_us`, `asymmetry_pct`, `msg_hex`, `msg_ok`.
* В `process_pulse_segment(...)` сформировать `pulse_info` со следующими ключами:

  * `start_abs`, `end_abs`, `length_ms`, `timestamp`
  * * все поля из `analyze_psk406(...)` выше.
  * Записать в `last_pulse_data` и **append** в `pulse_history: deque(maxlen=50)`.
* Обновить `/api/last_pulse`:

  * Вернуть: `{ items, last, history }`, где `history` — последние ≤20 импульсов.
  * Для сети усекать `msg_hex` до `msg_hex_short` (64 символа + «…»).
* Обновить фронтенд-рендер «Current»:

  * Добавить строки: **Bitrate**, **Pos/Neg phase**, **Rise/Fall**, **Asymmetry**, **Message (short HEX)**, **CRC/OK**.
  * Ничего тяжёлого — только вывод значений, polling уже есть.

## Формат ответа (строго)

1. **Короткий план** на 5–7 пунктов (≤10 строк).
2. **Патч-вставки**: только изменяемые фрагменты с контекстом ±3 строки, помечай `# STRICT_COMPAT`.

   * А) Глобалы: `from collections import deque`, `PULSE_HISTORY_MAX=50`, `pulse_history=deque(...)`.
   * Б) `def analyze_psk406(...):` как описано выше.
   * В) Вставка в `process_pulse_segment(...)` — формирование `pulse_info` и публикация.
   * Г) Обновление `/api/last_pulse`.
   * Д) Изменения в `renderCurrentStats(...)` (JS) — добавление полей.
3. **Чек-лист теста** (≤10 пунктов): команды запуска, 1 тест File-режима (ожидаемые поля/диапазоны), 1 тест RTL-режима, 3 вызова `curl` для API.
4. **Типичные ошибки** (3–5 пунктов) и как их поймать в логах.

## Критерии приёмки

* `/api/last_pulse` содержит `last.length_ms`, новые метрики (могут быть `null`), и массив `history` ≤20 элементов.
* В UI «Current» видны новые поля; при отсутствии значения — «—».
* При поступлении импульса `last_pulse` обновляется, ошибок/исключений в логах нет.
* Сегменты берутся из кольца корректной длины; при длинном импульсе нет «разрыва» через границу.

## Доп. примечания

* **Не переписывать файлы целиком.** Только точечные вставки с якорями «найди строку X — вставь ниже Y».
* Никаких новых зависимостей; все импорты — стандартная библиотека + уже существующие модули.
* Время считать через фактический `fs` (никаких 1e6).
* Для HEX — аккуратно обрамлять (моноширинный CSS класс, если он уже есть; если нет — не добавлять стили).

**Начинай.**
