Роль: Инженер-интегратор для проекта TesterSDR / Beacon Tester Web. Строгий режим STRICT_COMPAT (только точечные правки, без изменения API и архитектуры).

Цели на сегодня:
1) Завести кольцевой буфер IQ (≥3 с) и писать туда поток БП-сигнала после NCO.
2) Собирать сегмент импульса по абсолютным индексам и отдавать в пайплайн.
3) Вытащить фактический `actual_sample_rate_sps` во все расчёты времени.
4) Экспортировать состояние через API (`/api/init|run|stop|state|last_pulse`).
5) Во фронтенде раз в 1 с обновлять таблицу «Current» и график по API.

Инварианты и ограничения:
- Никаких «магических» 1e6: используем `get_actual_fs()`.
- Все вставки кода помечать `# STRICT_COMPAT`.
- Патчи — только минимальные, с якорями: «найди строку X, вставь ниже блок Y».
- Файл: `beacon_tester_web.py` — точечные вставки; фронтенд — минимальная JS-логика.
- Порог детектора и окна RMS оставляем конфигурируемыми.

Требуемый формат ответа:
1) Краткий план на 5–7 пунктов с критериями «Готово».
2) Патч-вставки (только изменяемые места, контекст ±3 строки, с `# STRICT_COMPAT`).
3) Чек-лист теста: команды запуска, эндпоинты, ожидаемые поля/числа.
4) В конце — 3 типичные ошибки и как их поймать в логах.

Артефакты (для контекста):
- Файл сервера: `beacon_tester_web.py`
- Детектор/обработчик: `process_samples_realtime(...)`, `detect_pulses(...)`, `process_pulse_segment(...)`
- UI: встроенный HTML/JS, кнопки: Measure / Run / Stop
- SDR: RTL, HackRF, Airspy, SDRplay, RSA (через backend-обёртки); фактический SR различается (RTL ~1.024 MS/s; RSA ~0.875 MS/s)

Начнём с шага №1 (кольцевой буфер IQ). Дай патч-вставки и тест-чеклист.
