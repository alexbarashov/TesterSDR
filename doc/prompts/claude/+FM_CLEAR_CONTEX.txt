# Этап A. Включить FM-график в режиме Run config + file

## Цель

Сделать так, чтобы в **Run** режиме формировались и отображались в UI те же FM-данные, что уже работают в **File** режиме:

* `STATE.fm_data` — массив частоты (Гц) во времени
* `STATE.fm_xs_ms` — ось времени (мс), совпадающая по границам с фазовым графиком текущего импульса

## Ограничения (STRICT_COMPAT)

* Не ломаем существующие контракты и поля JSON.
* Вся новая логика — аддитивно.
* Производительность: не ухудшить обработку импульса заметно (FM считать из уже вырезанного сегмента).

## Требуемые изменения

1. **Где считать FM (Run):**

   * Точка интеграции: внутри `process_pulse_segment(...)` — сразу после извлечения `iq_seg` и до/или после вызова текущего анализа PSK (на выбор, лучше после *финальной* “подрезки” сегмента, чтобы оси совпадали).
   * Вызвать тот же хелпер, что используется в File-ветке (например, `fm_discriminator(iq_seg, fs, ...)`), с **идентичными параметрами** фильтрации/децимации, как в File.
   * Результаты:

     * `freq_hz -> pulse_info["fm_data"]`
     * `xs_ms  -> pulse_info["fm_xs_ms"]`

2. **Совпадение осей времени:**

   * Убедиться, что при Run и File длина `fm_xs_ms` соответствует текущему отрисовываемому сегменту (те же нач/конц границы, без сдвига).
   * Если фаза строится на децимированном сигнале (×4), для FM использовать ту же/согласованную децимацию, чтобы графики визуально совпадали по времени.

3. **Проброс в STATE (без ручных присваиваний):**

   * `pulse_info.update(psk_result)` — уже есть.
   * Затем **вызвать** существующую утилиту `update_state_from_results(pulse_info)` (не делать отдельных `STATE.fm_* = ...` присваиваний).
   * Убедиться, что `update_state_from_results` уже поддерживает поля `fm_data` и `fm_xs_ms`. Если нет — добавить две строки:

     * `if "fm_data"  in res: STATE.fm_data  = res["fm_data"]`
     * `if "fm_xs_ms" in res: STATE.fm_xs_ms = res["fm_xs_ms"]`

4. **Инициализация и API:**

   * В `init_state_fields()` убедиться, что `STATE.fm_data` и `STATE.fm_xs_ms` инициализируются `None`.
   * В `/api/status` эти поля уже должны возвращаться. Если нет — добавить их в JSON-ответ.

## Псевдо-патч (ориентир)

```python
# --- внутри process_pulse_segment(...), после того как получили iq_seg и fs ---
psk_result = analyze_psk406(iq_seg, fs, ...)   # как сейчас
pulse_info.update(psk_result)

# NEW: FM discriminator (параметры как в File)
fm_freq_hz, fm_xs_ms = fm_discriminator(iq_seg, fs,  # те же аргументы
                                        # ... те же опции/децимация/полоса
                                        )
pulse_info["fm_data"]  = fm_freq_hz.tolist()   # если нужно сериализовать
pulse_info["fm_xs_ms"] = fm_xs_ms.tolist()

# Единый проброс в STATE
update_state_from_results(pulse_info)
```

> Примечание: если `fm_discriminator` возвращает numpy-массивы, приведите к спискам **только** в том месте, где требуется сериализация (если требуется). В остальном держите `np.ndarray` — как у вас принято.

## Тест-план (обязательный)

1. **Сравнение File vs Run на одном и том же импульсе:**

   * Взять один `*.cf32`.
   * File-анализ → получить `/api/status` → сохранить `A.fm_data` и `A.fm_xs_ms`.
   * Run-анализ (backend=file) → после детекции → `/api/status` → `B.*`.
   * Сравнить равенство длины осей, близость значений (допускается небольшая разница от границ вырезки/фильтра).

2. **Визуальная проверка:**

   * В UI включить “двойное окно” (фаза+FM). При зум/панорамировании временные оси совпадают, пики/ямы частоты совпадают с фазовыми переходами.

3. **Пустой/шумовой кейс:**

   * При отсутствии импульса FM-поля в статусе присутствуют как `null`/пустые, ошибок нет.

4. **Производительность и стабильность:**

   * В Run при типичной нагрузке нет заметной просадки FPS/обновления UI.
   * Исключений/переполнений буферов нет.

## Критерии приёмки

* В режиме Run UI видит и рисует FM-график так же, как в File.
* Оси времени совпадают визуально.
* `/api/status` стабильно отдаёт `fm_data`/`fm_xs_ms` в обоих режимах.

---

# Этап B. “Санитарная уборка” (минимальные безопасные правки)

## Цель

Уменьшить дублирование и рассинхронизацию путей File/Run, не меняя внешних контрактов.

## Задачи

1. **Оставить единый `/api/status`:**

   * В файле есть дубликаты определения эндпоинта статуса. Оставить **один** вариант, самый полный.
   * Убедиться, что он возвращает **все** ключи, ожидаемые UI (включая `preamble_ms`, `total_ms`, `prise_ms`, `pos_phase`, `neg_phase`, `ph_rise`, `ph_fall`, `symmetry_pct`, `rms_dbm`, `freq_hz`, `bitrate_bps`, `t_mod`, `hex_message`, `phase_data`, `xs_ms`, `fm_data`, `fm_xs_ms`).

2. **Единый способ обновления STATE:**

   * Удалить “ручные” присваивания `STATE.* = ...` в File-ветке; везде использовать **только** `update_state_from_results(res)`.
   * Проверить, что File путь после `process_cf32_file(...)` вызывает утилиту один раз.

3. **Инициализация STATE ключей:**

   * В `init_state_fields()` покрыть весь перечень полей (включая FM), установить `None` по умолчанию. Так `/api/status` всегда отдаёт полный набор ключей.

4. **Логи:**

   * Оставить по одному понятному debug-логу на событие (например, расчёт преамбулы, запуск FM-демодуляции). Удалить дубли/спам.
   * Не логировать крупные массивы в INFO.

5. **Докстринги и комментарии:**

   * Над `update_state_from_results` добавить докстринг с перечислением поддерживаемых ключей.
   * К коротким хелперам (например, `fm_discriminator`) дописать аргументы/единицы измерения, чтобы избежать путаницы (Гц/мс/рад).

6. **Микро-DRY в коде:**

   * Если есть повторяющиеся куски нормализации сегмента (обрезка по порогу до/после импульса), вынести в мини-хелпер (аддитивно) и переиспользовать в File и Run, **не меняя** их внешнюю логику/параметры.

## Псевдо-патчи (ориентиры)

**Единый /api/status (фрагмент):**

```python
@app.route("/api/status")
def api_status():
    return jsonify({
        # … существующие поля …
        "preamble_ms": STATE.preamble_ms,
        "total_ms":    STATE.total_ms,
        "prise_ms":    STATE.prise_ms,

        "pos_phase":    STATE.pos_phase,
        "neg_phase":    STATE.neg_phase,
        "ph_rise":      STATE.ph_rise,
        "ph_fall":      STATE.ph_fall,
        "symmetry_pct": STATE.symmetry_pct,

        "rms_dbm":     STATE.rms_dbm,
        "freq_hz":     STATE.freq_hz,
        "bitrate_bps": STATE.bitrate_bps,
        "t_mod":       STATE.t_mod,

        "hex_message": STATE.hex_message,

        "phase_data": STATE.phase_data,
        "xs_ms":      STATE.xs_ms,

        "fm_data":  STATE.fm_data,
        "fm_xs_ms": STATE.fm_xs_ms,
    })
```

**File-ветка → единый апдейт:**

```python
result = process_cf32_file(path, fs, ...)   # как сейчас
update_state_from_results(result)           # вместо набора ручных присваиваний
```

**Инициализация (дополнить при необходимости):**

```python
STATE.fm_data  = None
STATE.fm_xs_ms = None
```

## Тест-план

* **Регресс API:** `/api/status` стабильно содержит все ключи, без ошибок сериализации.
* **Регресс File/Run:** все значения на том же входном сигнале согласованы (различия — только из-за границ вырезки).
* **Логи:** нет дубликатов эндпоинтов/обработчиков; лог читаемый и умеренный.
* **Производительность:** время обработки импульса не ухудшилось заметно.

## Критерии приёмки

* FM работает в Run и визуально совпадает с File.
* `/api/status` один, возвращает полный набор полей.
* Весь проброс параметров — через `update_state_from_results`, без ручных исключений.
* Все ключи и типы совместимы с текущим UI (STRICT_COMPAT).
