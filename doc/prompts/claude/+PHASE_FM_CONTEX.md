
# Дополнение к единому ТЗ: графики **406 phase** и **406 in-burst FR**

## 1) Общие правила для обоих графиков

* **UI копируем 1:1 из `beacon_tester_buf-ring_web.py`**: контейнер, подписи осей, легенды, сетка, маркеры.
* **Масштаб времени** управляется общим контролом **Time scale (ms/div)**, как в `_web`.
  Видимая ширина окна: `span_ms = time_scale_ms_per_div × 10`.
* **Источник данных — `dsp_service`**. В браузере ничего не считаем: фаза/частота и даунсэмплинг готовятся на сервере.
* **Плотность точек**: ~1000 (допустимо 800–1200) на окно; даунсэмплинг на сервере (min/max-по-пикселю или экв.).

## 2) Интеграция в `dsp2web`

* В селекторе VIEW/Graph добавить пункты: **“406 phase”**, **“406 in-burst FR”** (точные ярлыки как в `_web`).
* При активации каждого режима:

  1. читаем текущее `time_scale_ms_per_div`;
  2. считаем `span_ms = time_scale_ms_per_div × 10`;
  3. запрашиваем соответствующий эндпоинт у `dsp_service`;
  4. отрисовываем график скопированной из `_web` функцией.
* На **SSE (`pulse`/`psk`)**: если активен соответствующий график — повторить запрос и перерисовать.
* При изменении **Time scale** — немедленно перезапрашивать данные и перерисовывать.

## 3) “406 phase”

### Данные (минимальный контракт ответа от `dsp_service`)

```json
{
  "phase_xs_ms": [ ... ],   // X в мс, длина ≤ ~1000
  "phase_ys_rad": [ ... ],  // Y в радианах, та же длина
  "markers_ms": [ ... ],    // опц.: времена вертикальных меток (границы полубитов/битов)
  "preamble_ms": [t0, t1],  // опц.: диапазон преамбулы для заливки
  "baud": 400.0             // опц.: для подписи/легенды
}
```

* Эндпоинт (пример): `GET /api/pulse_phase?span_ms=S&offset_ms=O&points=N`
  (или включить `phase_*` в ответ `/api/last_pulse` — как это уже сделано в `_web`).
* Отрисовка: линия фазы; вертикальные метки из `markers_ms`; полупрозрачная заливка преамбулы.
  Стили/подписи сетки — **как в `_web`**.

## 4) “406 in-burst FR” (частота внутри посылки)

### Данные (минимальный контракт ответа от `dsp_service`)

```json
{
  "fr_xs_ms": [ ... ],      // X в мс, длина ≤ ~1000
  "fr_ys_hz": [ ... ],      // Y в Гц (или кГц — ровно как в `_web`), та же длина
  "markers_ms": [ ... ],    // опц.: границы полубитов/битов
  "preamble_ms": [t0, t1]   // опц.: подсветка преамбулы
}
```

* Эндпоинт (пример): `GET /api/pulse_inburst_fr?span_ms=S&offset_ms=O&points=N`
  (или вернуть блок `fr_*` в `/api/last_pulse` — как в `_web`).
* Отрисовка: линия мгновенной частоты (CFO-трек/IF-частота в посылке — **ровно в тех единицах и с теми подписями**, как в `_web`).
  Сетка/подписи/легенда — **скопировать**.

## 5) Поведение и UX (оба графика)

* **Shared X**: ось времени синхронизирована с остальными графиками по `Time scale`.
* **Заглушка**: если данных ещё нет — показывать “[no data]” (текст/стиль как в `_web`).
* **Производительность**: не превышать ~1200 точек на ответ; рендер без подлагиваний.
* **Без перерасчётов на клиенте**: фаза и FR формируются в `dsp_service`.

## 6) Критерии приёмки

1. В `dsp2web` доступны режимы **“406 phase”** и **“406 in-burst FR”**, визуально/поведенчески **идентичны `_web`**.
2. Ширина окна = `ms/div × 10`, изменение Time scale мгновенно меняет оба графика.
3. На новые события `pulse/psk` активный график обновляется автоматически.
4. Пики/фронты не теряются (серверный min/max-даунсэмплинг).
5. Никаких клиентских DSP — только отрисовка.

## 7) Чек-лист внедрения (коротко)

* Скопировать из `_web` HTML/CSS/JS двух графиков (те же `id`/классы/функции).
* Добавить два пункта View и их обработчики.
* Реализовать проксирующие запросы к `dsp_service` (два эндпоинта или расширенный `/api/last_pulse`).
* Привязать обновление к **Time scale** и к SSE (`pulse`/`psk`).
* Проверить единицы измерения (рад/Гц|кГц) — **как в `_web`**.


