
# ТЗ: Горизонтальная прокрутка графика фазы (передвижение по времени влево/вправо)

## Цель

Добавить в веб-интерфейс **управляемое перемещение по оси времени** для графика **406 Phase** (панорамирование влево/вправо). В «живом» режиме всё продолжает работать как сейчас; при ручном режиме пользователь может листать историю во времени.

## Жёсткие ограничения (STRICT_COMPAT)

1. Ничего не ломаем: текущие API и поведение по умолчанию **без изменений**.
2. Новые параметры — **опциональные**; если их нет, работает как сейчас (авто-фит «последнего импульса»/последних данных).
3. Не увеличивать объём передаваемых данных без необходимости — серверная агрегация/даунсемплинг обязательны.

## Новые термины/состояния

* **Viewport** (окно просмотра): временной интервал, который рисуем на графике.

  * `t0_ms` — начало окна (мс от «нуля» сессии или от начала файла/буфера).
  * `span_ms` — длительность окна (ширина по X).
* **Live mode** (живой режим): текущий «Update = ON».
* **Manual mode** (ручной режим): «Update = OFF» или включён «Lock Viewport».

## UI-изменения

1. **Кнопки навигации по времени** в блоке «MODE» рядом с `Time scale`:

   * `◀ Left` — сдвиг окна на `shift_frac * span_ms` влево.
   * `▶ Right` — сдвиг окна на `shift_frac * span_ms` вправо.
   * `⏮ Begin` — прыгнуть к началу доступных данных.
   * `⏭ End` — прыгнуть к концу (последние данные).
   * Значение `shift_frac` по умолчанию 0.25 (25% ширины окна).
2. **Перетаскивание мышью** (drag on canvas):

   * ЛКМ зажали и тянем: сдвигаем `t0_ms` на величину, пропорциональную пиксельному сдвигу.
3. **Клавиатура** (если возможно без конфликтов):

   * `←` / `→` — смещение на 10% span.
   * `Home` / `End` — к началу / к концу.
4. **Индикатор режима**:

   * Если пользователь начал панорамирование, автоматически включить «Manual mode» (или показать «Lock Viewport: ON»).
   * Кнопка `Go Live` для быстрого возврата к хвосту данных (последним значениям) и включения авто-обновления.
5. **Синхронизация панелей**:

   * Если у нас есть доп. графики (FM/FFT), **делим общий Viewport** (общая ось времени). Один набор кнопок рулит всеми.

## Клиентское состояние (frontend)

Новый объект `viewport_state`:

```json
{
  "mode": "live" | "manual",
  "t0_ms": <float>,    // начало окна
  "span_ms": <float>,  // ширина окна
  "shift_frac": 0.25   // коэффициент шага кнопок
}
```

* При старте (или `Update=ON`) `mode="live"`, сервер даёт «хвост» как сейчас.
* При любом пользовательском сдвиге — `mode="manual"` и `Update` временно игнорируется.
* Кнопка `Go Live` возвращает `mode="live"` и сбрасывает `viewport_state` в поведение по умолчанию.

## Серверное API (добавки, без лома старого)

Расширяем существующую конечную точку, которая отдаёт данные для отрисовки фазы (например `/api/state` или специализированный `/api/phase`). Новые **опциональные** query-параметры:

* `t0_ms` (float) — желаемое начало окна.
* `span_ms` (float) — желаемая ширина окна.
* `max_points` (int) — максимум точек на серию для даунсемплинга (по умолчанию 1000–2000).

**Правила:**

1. Если параметры не переданы → как сейчас (авто-хвост).
2. Если переданы → вернуть ровно этот интервал, **если** он доступен в буфере/файле. Если выходим за границы — подрезать к допустимому.
3. На сервере применить **даунсемплинг min/max-по-пикселю** (bucket downsampling) под `max_points`:

   * В расчёте использовать только **видимый интервал**.
   * Для ступенчатых сигналов (фаза/биты) допускается «step-render friendly» агрегация (но min/max достаточно).
4. Вернуть JSON с метаданными окна, чтобы клиент знал, что реально нарисовано:

```json
{
  "viewport_applied": { "t0_ms": <float>, "span_ms": <float> },
  "x_ms": [ ... ],            // даунсемплированные X
  "phase_rad": [ ... ],       // даунсемплированные Y
  "markers": { "bits": [...], "preamble": [t0,t1], ... }, // опционально
  "limits": { "t_min_ms": <float>, "t_max_ms": <float> }  // доступные границы
}
```

## Логика клиент ↔ сервер

* Клиент хранит `viewport_state`.
* При каждом сдвиге/зуме отправляет запрос с `t0_ms` и `span_ms`.
* Если сервер вернул `limits`, клиент ограничивает дальнейшие шаги (disable `◀` на самом начале, `▶` на самом конце).
* В `live` режиме клиент **не** отправляет `t0_ms`/`span_ms` (или может отправить `t0_ms=-1` как «хвост» — но лучше просто не слать).

## Поведение в режимах

* **Live**: авто-обновление по таймеру/пуллингу, график «прилипает» к концу. Кнопки навигации активны, но первый ручной шаг переводит в **Manual**.
* **Manual**: авто-обновление отключено. Доступны кнопки/drag/клавиши. Кнопка `Go Live` возвращает авто-режим.

## Производительность и лимиты

* `max_points` по умолчанию 1500 (в пределах 1000–2000).
* Ответ сервера по объёму ≤ ~200–300 КБ (цель).
* Время ответа < 100 мс при работе с RAM-буфером; при работе с файлом допускается до 300 мс.
* Отрисовка кадра в браузере ≤ 16 ms для плавности.

## Тест-кейсы (приёмка)

1. **По умолчанию (ничего не трогали):** всё ведёт себя как сейчас (live), график двигается вместе с новыми данными.
2. **Manual drag:** зажать ЛКМ и сместить влево → график листается назад; `Update` визуально становится «Lock Viewport ON» (или `mode=manual`).
3. **Кнопки ◀/▶:** шаг сдвига = 25% ширины окна; многократные нажатия корректно останавливаются на границах данных.
4. **Home/End:** прыжки к началу/концу доступного диапазона.
5. **Go Live:** из Manual возвращает к хвосту и включает авто-прокрутку.
6. **Синхронизация панелей:** при наличии второй панели (FM) обе двигаются синхронно, общая ось времени.
7. **Даунсемплинг:** на большом интервале иголки/пики (фазовые фронты) визуально не пропадают — min/max сохраняет экстремумы.
8. **Границы:** запросы за пределы корректно подрезаются, UI блокирует дальнейшее движение в этом направлении.
9. **Производительность:** при `max_points=1500` лагов нет; объём ответа не превышает лимиты.

## Риски и как их избежать

* **Разъезд осей между панелями** → единый `viewport_state` и единые запросы.
* **Слишком тяжёлые ответы** → обязательный серверный даунсемплинг и `max_points`.
* **Случайный выход из live** → явный индикатор режима и кнопка `Go Live`.

## Что отдать на выход

1. Обновлённый frontend с кнопками/drag/клавишами и `viewport_state`.
2. Обновлённый backend-эндпоинт (или расширение текущего) с параметрами `t0_ms`, `span_ms`, `max_points`, и серверным min/max-даунсемплингом.
3. Короткая инструкция по интеграции (1–2 абзаца), список изменённых файлов.
4. Скринкаст 20–30 сек: листание назад/вперёд, `Go Live`, синхронный сдвиг панелей.


