# ТЗ для **FM-plot** с «телеметрией времени» (тайминг-логи), 
которая **по умолчанию выключена** и **не меняет логику**.

# Цели

* Замерить задержки «импульс → график» на стороне FM-plot.
* Не влияя на алгоритмы и UI.
* В боевой версии телеметрия не мешает и не даёт накладных расходов (выключена одним флагом).

# Негативные цели

* Не меняем параметры детектора/фильтров.
* Не добавляем задержек (`sleep`), не меняем частоты опроса/отрисовки.
* Не меняем формат уже существующих сообщений и данных для графиков.

# Включение/выключение

* Телеметрия управляется **одним «компиляционным» флагом** (на практике — константа + переменная окружения):

  * Константа в коде: `TELEMETRY_ENABLED = False` (дефолт).
  * Если задано `BEACON_TELEMETRY=1` в окружении — телеметрия включается (перекрывает константу).
  * Дополнительно: `BEACON_TELEM_LEVEL=basic|verbose` (дефолт `basic`).

# Что логируем (метки)

Метки не меняют поведение; только печатают строки лога при включённой телеметрии:

1. `t_read_start` / `t_read_end` — начало/конец чтения блока семплов.
2. `t_proc_start` — вход в обработку блока (до детекции).
3. `t_thresh_first` — момент первого пересечения порога в блоке (старт импульса; один раз на импульс).
4. `t_pulse_enqueued` — постановка данных импульса в очередь/структуру, из которой читает UI-часть FM-plot.
5. `t_ui_tick` — момент, когда UI «подхватил» импульс из очереди и начал обновлять линии.
6. `t_ui_drawn` — момент окончания отрисовки (после `plt.pause(...)`/обновления фигур).

> Если в текущей реализации FM-plot нет явной «очереди» импульса — используем ближайшую точку, где «данные готовы для рисования» (например, когда заполнен буфер окна импульса). Семантика сохраняется: «готов к потреблению UI».

# Формат строки лога

Каждая запись — одна строка, чтобы легко парсить `grep/awk`:

```
[TM] tag=<READ_START|READ_END|PROC_START|THRESH_FIRST|ENQ|UI_TICK|UI_DRAWN> \
t_ms=<мс_от_старта_процесса> dt_ms=<мс_от_предыдущей_метки_по_этому_pulse_id> \
pulse_id=<int|-1> sr_sps=<int> read_chunk=<int> backend=<str> mode=<str> note="<опц.>"
```

* Время берём из `time.perf_counter_ns()` (монотонно и с высокой точностью).
* `pulse_id` — целое, стабильно отличающее импульсы в рамках сессии (рекомендуется взять «абсолютный индекс начала импульса» или возрастающий счётчик). Если метка не относится к конкретному импульсу — `-1`.
* `backend/mode`/текущий `sr_sps` и `read_chunk` добавляем один раз в начале и к ключевым меткам для контекста.
* Уровни:

  * `basic`: только ключевые метки (перечень выше).
  * `verbose`: + краткие параметры окна/порогов, длины массива точки (без сырых IQ).

# Организация кода (минимально-инвазивно)

1. В начале файла:

   * Импорт: `import os, time, logging` и `from logging.handlers import RotatingFileHandler`.
   * Константа `TELEMETRY_ENABLED = False`.
   * Чтение окружения:

     ```python
     _telemetry_on = TELEMETRY_ENABLED or os.getenv("BEACON_TELEMETRY") == "1"
     _telemetry_level = os.getenv("BEACON_TELEM_LEVEL", "basic")
     ```
   * Инициализация отдельного логгера **только если** `_telemetry_on`:

     * Имя: `"telemetry"`.
     * Хэндлер: `RotatingFileHandler("logs/telemetry.log", maxBytes=2_000_000, backupCount=5)` **и** StreamHandler (консоль) в `verbose`.
     * Формат: `'%(asctime)s %(message)s'`, `datefmt='%H:%M:%S'`.
     * Уровень: INFO.

2. Вспомогательный модуль/класс (в этом же файле, чтобы не плодить зависимости):

   ```python
   class Telemetry:
       def __init__(self, logger, enabled):
           self.enabled = enabled
           self.log = logger.info if enabled else (lambda *a, **k: None)
           self.t0_ns = time.perf_counter_ns()
           self.last_ns_by_id = {}

       def now_ms(self):
           return (time.perf_counter_ns() - self.t0_ns) / 1e6

       def emit(self, tag, pulse_id=-1, note=None):
           if not self.enabled: return
           now_ns = time.perf_counter_ns()
           t_ms = (now_ns - self.t0_ns) / 1e6
           prev = self.last_ns_by_id.get(pulse_id, None)
           dt_ms = (now_ns - prev)/1e6 if prev else 0.0
           self.last_ns_by_id[pulse_id] = now_ns
           self.log(f"[TM] tag={tag} t_ms={t_ms:.3f} dt_ms={dt_ms:.3f} pulse_id={pulse_id} "
                    f"sr_sps={self._sr} read_chunk={self._chunk} backend={self._backend} mode={self._mode}"
                    + (f' note="{note}"' if note else ""))
       # значения контекста задаём извне:
       _sr = 0; _chunk = 0; _backend = "NA"; _mode = "NA"
   ```

   * В месте инициализации FM-plot создаём `tm = Telemetry(t_logger, _telemetry_on)` и **один раз** забиваем контекст: `tm._sr = <sample_rate>`, `tm._chunk = <READ_CHUNK>`, `tm._backend = <...>`, `tm._mode = <...>`.

3. Вставки меток (обёртки `if _telemetry_on: tm.emit(...)`) в конкретных местах:

   * Перед чтением блока: `tm.emit("READ_START", -1)`.
   * Сразу после чтения: `tm.emit("READ_END", -1, note=f"n={len(samples)}")`.
   * Перед обработкой: `tm.emit("PROC_START", -1)`.
   * В момент фиксации «первого порога для импульса»: `tm.emit("THRESH_FIRST", pulse_id)`.
   * Непосредственно перед постановкой «импульса» в потребляемую структуру: `tm.emit("ENQ", pulse_id)`.
   * При извлечении данных для перерисовки (UI-цикл): `tm.emit("UI_TICK", pulse_id)`.
   * Сразу после отрисовки (после `plt.pause(...)` или после `canvas.draw_idle()`+цикла событий): `tm.emit("UI_DRAWN", pulse_id)`.

4. Никаких изменений таймеров, частоты опроса, downsample и т.п. — только `emit()`.

# Производительность

* В выключенном состоянии (`_telemetry_on=False`) накладные расходы — нулевые (вызов пустой лямбды).
* В включённом состоянии — O(нескольких десятков µs) на метку: форматирование строки + I/O в файл (скручиваем размером и бэкапами).

# Выводы/метрики, которые должны получиться из логов

Из логов можно посчитать:

* **Latency чтения**: `READ_END - READ_START`.
* **Latency «детекция → очередь»**: `ENQ - THRESH_FIRST`.
* **Latency «очередь → отрисовано»**: `UI_DRAWN - ENQ`.
* **Сквозная latency**: `UI_DRAWN - THRESH_FIRST`.
* (Опционально) средние/перцентильные значения по всем импульсам.

# Тест-план при приёмке

1. **FILE-режим**:

   * Включить телеметрию: `BEACON_TELEMETRY=1`.
   * Прогнать тестовый файл с минимум 3 импульсами.
   * Проверить, что в `logs/telemetry.log` присутствуют все пары меток (`THRESH_FIRST`, `ENQ`, `UI_TICK`, `UI_DRAWN`) с одинаковым `pulse_id`.
   * Убедиться, что сквозная задержка не зависит от «внешней сети/USB» и повторяется в пределах разумного разброса.

2. **RTL-режим**:

   * Повторить сценарий в эфире.
   * Сравнить «READ_*» и «ENQ→UI_*» с FILE-режимом; ожидать большей вариативности на чтении.

3. **Выключение**:

   * Убрать `BEACON_TELEMETRY`, перезапустить — в логи ничего не пишется, поведение FM-plot неизменно.

# Аудит/безопасность

* Не логируем сырые IQ/длинные массивы.
* В `verbose` допустимы краткие сводки (длина окна, min/max, rms), без приватных данных.
* Логи не меняют формат существующих сообщений, не ломают UX.

# Точки отказа/риски

* Отсутствие папки `logs/` → создаём при инициализации телеметрии (если включена).
* Большие логи → ротация файла (2 МБ × 5).
* `pulse_id` должен быть **строго** стабилен внутри жизненного цикла импульса: приёмка проверяет.

# Что сдаём

* Обновлённый `beacon406_PSK_FM-plot.py`:

  * Блок инициализации телеметрии.
  * Класс `Telemetry`.
  * Точки `tm.emit(...)` в перечисленных местах.
  * Без иных изменений алгоритмов/UI.
* `README_Telemetry.md` (кратко: как включить, где смотреть, пример разбора).

Если хочешь, могу сразу подготовить минимальный патч с этими вставками (без изменения логики), а ты прогоняешь на FILE → RTL и кидаешь первые логи — по ним уже построим таблицу задержек и найдём «узкое место».
