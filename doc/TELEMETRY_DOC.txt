
# Результаты по 6 тестам

1. **-plot / FILE**
   Сквозная `THRESH_FIRST→UI_DRAWN` ≈ **~182 мс**.
   Узкое место: либо `ENQ→UI_TICK ~174 мс`, либо `THRESH_FIRST→ENQ ~166 мс`.

2. **-plot / RTL (rtlsdr, Fs≈1.024 МS/s)**
   Сквозная ≈ **0.63–0.67 с** (= ~521 мс валидация длины + ~64 мс квант чтения + немного обработки).
   Доставка/отрисовка быстрые (≈2–12 мс).

3. **-dsp2plot **
   `get_last_pulse` ACK **1.8–3.2 с**, из-за этого «шпили» у `get_status` до **3–4 с**. Блокировка REP тяжёлым хэндлером.

4. **-dsp2plot / FILE **
   `get_last_pulse` **~73–128 мс**, `get_status` **0–5 мс** (редко 45–129 мс при подготовке кэша), `start_acquire` мгновенно.

5. **-dsp2plot / FILE (повторные переключения файлов)**
   Поведение стабильно: быстрые ACK, редкие всплески в моменты «PSK processing …» (подготовка кэша).

6. **-dsp2plot / RTL (soapy_rtl)**
   `get_last_pulse` **~73–102 мс**, `get_status` в основном **0–10 мс** (иногда 20–95 мс при «PSK processing …»).
   Зависаний REP больше нет.

---

# Где править, чтобы ускорить (по возрастанию эффекта)

1. **Снизить `read_chunk` 65536→32768 (или 16384)**
   Выигрыш: **~32–48 мс** к «видимости» (меньший квант реакции).

2. **UI: ограничить ответ `max_samples=20–40k` + `downsample="minmax"`**
   Выигрыш: **~20–60 мс** на ACK `get_last_pulse` и меньше трафика (UX косвенно быстрее).

3. **UI: опрашивать пульс только ПО СОБЫТИЮ, с шагом 0.1–0.2 с; убрать `force_request` в FILE**
   Выигрыш: до **~150 мс** (в FILE устраняет задержку `ENQ→UI_TICK ~174 мс` из раннего теста) и меньше лишних вызовов.

4. **Сервис: `get_last_pulse` только из кэша (нет кэша → мгновенный `ok=False`)**
   Выигрыш: **~1.7–3.1 с на вызов** и исчезновение блокировок REP (повышает отзывчивость всего приложения).

5. **UX-апгрейд: добавить `pulse_started` (превью сразу) + `pulse_finalized`**
   Выигрыш по «видимости на графике»:
   • RTL: **−~0.57–0.60 с** (станет ~квант чтения ≈ 32–64 мс + доставка 0–20 мс)
   • FILE: **−~120 мс** (например, 180 → ~60 мс)

> Всё остальное уже в норме: доставка PUB и отрисовка укладываются в **~3–12 мс** и оптимизации не требуют.

ок, считаем это **Тест #6 (RTL, soapy_rtl)**. Ниже — переписанные итоги и что делать дальше.

# Результаты теста №6

* **Бэкэнд:** RTL2832U (soapy_rtl), Fs ≈ **1.024 MS/s**, **BB-shift −37 kHz** (Zero-IF) — корректно.
* **`get_status`**: в основном **0–10 мс**, редкие всплески **20–145 мс** — совпадают с строками `PSK processing ...` (разовая подготовка кэша).
* **`get_last_pulse` (из кэша)**: **~84–105 мс** на разных импульсах (`slice=[0:N]%`).
* **Блокировок REP нет**: параллельные `get_status` остаются быстрыми рядом с `get_last_pulse`.

# Что делать дальше (по убыванию эффекта)

1. **Добавить превью `pulse_started` → «видимость» сразу.**
   Ожидаемый выигрыш: первый видимый график через **квант чтения + 0–20 мс**, т.е. сейчас ~**64–80 мс**; при меньшем чанке — ещё быстрее.

2. **Снизить `read_chunk` 65536 → 32768 (или 16384).**
   Ожидаемый выигрыш к «видимости» превью: **−32…−48 мс**.

3. **Урезать объём ответа для UI.**
   Запрашивать `max_samples = 20–40k` + `downsample="minmax"` (вместо полного среза).
   Ожидаемый выигрыш по ACK `get_last_pulse`: **−20…−60 мс** и меньше трафика.

4. **Оставить текущую модель кэша и контроль «PSK processing …».**
   Всплески `get_status` до 50–145 мс — нормальны при доготовке кэша; блокировок нет. Для наблюдения оставьте телеметрию на тегах `CACHE_WRITE`, `PUB_PULSE`, `REP_*` (по желанию).

# Целевые метрики после докрутки

* `get_last_pulse`: **≤30–80 мс** (за счёт урезания данных).
* «Видимость импульса» с превью: **≈ квант чтения (16–64 мс) + доставка 0–20 мс**.
* `get_status`: p99 **≤100–150 мс** (редко, во время подготовки кэша).
