# Обмен данными между программой и веб-интерфейсом

## 1. Структура обмена

### **A. Загрузка файла (Upload)**
```
Веб → Backend: CF32 файл через POST /api/upload
Backend → Веб: JSON с результатами обработки
```

### **B. Периодический опрос (Polling)**
```
Веб → Backend: GET /api/status (каждые 500мс)
Backend → Веб: JSON с полными данными состояния
```

### **C. Управляющие команды**
```
Веб → Backend: POST /api/{measure,run,cont,break}
Backend → Веб: JSON подтверждение
```

## 2. Размеры входных данных

### **CF32 файлы (входные):**
- **Малые файлы**: 250-660 КБ (AIS сигналы)
- **Средние файлы**: 1.7-2.2 МБ (короткие захваты)
- **Типичные файлы**: 4.5-5.7 МБ (стандартные захваты маяков)
- **Большие файлы**: 10-11 МБ (длинные записи 121 МГц)

### **Структура CF32:**
- **Формат**: Complex Float32 (I+Q пары)
- **Размер образца**: 8 байт (4 байта I + 4 байта Q)
- **Частота дискретизации**: 1 МГц
- **Пример**: Файл 4.56 МБ = 570,000 комплексных образцов = 0.57 секунды записи

## 3. Обработка данных в Backend

### **Этапы обработки файла:**
1. **Загрузка**: `np.fromfile()` → комплексный массив
2. **RMS детекция**: Поиск импульса по порогу -60 dBm
3. **Извлечение сегмента**: Отрезок с импульсом (обычно 100-300мс)
4. **Фазовая обработка**: `process_psk_impulse()` → фазовые данные
5. **Демодуляция**: `phase_demod_psk_msg_safe()` → HEX сообщение
6. **Децимация**: Сокращение до управляемого размера

### **Типичные размеры после обработки:**
- **Исходный CF32**: 570,000 образцов (4.56 МБ)
- **Сегмент импульса**: ~100,000 образцов (после детекции)
- **Фазовые данные**: ~25,000 точек (после децимации 4x)
- **Временная ось**: ~25,000 точек (соответствует фазе)

## 4. Данные передаваемые в веб

### **JSON ответ /api/status (основной поток данных):**

```javascript
{
  // Метаданные (малые объемы)
  "running": false,
  "protocol": "N",
  "beacon_model": "Beacon N",
  "hex_message": "FFFED080020000007FDFFB0020B783E0F66C", // ~36 символов

  // Числовые параметры (32 поля × 8 байт = 256 байт)
  "fs1_hz": 406025000.0,
  "phase_pos_rad": 1.234,
  "t_rise_mcs": 45.6,
  "bitrate_bps": 400.0,
  // ... всего около 30 числовых полей

  // ОСНОВНЫЕ ДАННЫЕ - массивы для графика:
  "phase_data": [массив из ~25,000 чисел],     // ~200 КБ
  "xs_fm_ms": [массив из ~25,000 чисел]       // ~200 КБ
}
```

### **Расчет объемов данных:**

**Без оптимизации (было проблемой):**
- **phase_data**: 128,999 точек × 8 байт = ~1.03 МБ
- **xs_fm_ms**: 128,999 точек × 8 байт = ~1.03 МБ
- **Остальные поля**: ~10 КБ
- **ИТОГО JSON**: ~2.1 МБ + JSON overhead = **~5.2 МБ**

**С децимацией (текущая версия):**
- **phase_data**: 25,000 точек × 8 байт = ~200 КБ
- **xs_fm_ms**: 25,000 точек × 8 байт = ~200 КБ
- **Остальные поля**: ~10 КБ
- **ИТОГО JSON**: ~420 КБ + JSON overhead = **~500 КБ**

## 5. Проблемы с производительностью

### **JavaScript Stack Overflow (исправлено):**
```javascript
// ПРОБЛЕМА: Math.min(...phaseData) не работает с >100K элементов
const minPhase = Math.min(...phaseData); // ❌ Stack Overflow

// РЕШЕНИЕ: Используем reduce
const minPhase = phaseData.reduce((min, val) => Math.min(min, val), phaseData[0]); // ✅
```

### **Большие HTTP ответы:**
- **Проблема**: 5.2 МБ JSON ответы каждые 500мс
- **Решение**: Децимация до 2000 точек максимум
- **Результат**: 82 КБ ответы (65× уменьшение)

## 6. Сетевой трафик

### **Типичная сессия:**
1. **Загрузка файла**: 1 раз × 5 МБ = 5 МБ upload
2. **Ответ загрузки**: 1 раз × 1 КБ = 1 КБ download
3. **Статус опрос**: 2 раза/сек × 500 КБ = 1 МБ/сек download
4. **Команды**: ~10 раз × 100 байт = 1 КБ

**Общий трафик за минуту работы:**
- **Upload**: 5 МБ (единовременно)
- **Download**: 60 МБ (опрос статуса)
- **ИТОГО**: ~65 МБ/минуту

## 7. Оптимизации

### **Реализованные:**
- Децимация массивов до 2000 точек
- Безопасные JavaScript операции с массивами
- Сжатие JSON ответов

### **Возможные улучшения:**
- WebSocket вместо HTTP polling
- Дифференциальные обновления (только изменения)
- Сжатие gzip на HTTP уровне
- Прогрессивная загрузка графиков

## 8. Технические детали

### **API Endpoints:**
- `POST /api/upload` - Загрузка и обработка CF32 файлов
- `GET /api/status` - Основной поток данных (500мс интервал)
- `POST /api/measure` - Инициализация системы
- `POST /api/run` - Одиночный захват
- `POST /api/cont` - Непрерывный захват
- `POST /api/break` - Остановка захвата

### **BeaconState структура:**
```python
@dataclass
class BeaconState:
    # Основные данные для графика
    phase_data: list = field(default_factory=list)  # Фазовые данные
    xs_fm_ms: list = field(default_factory=list)    # Временная ось

    # Метаданные
    hex_message: str = ""                            # Декодированное сообщение
    running: bool = False                            # Статус работы

    # Численные параметры (~30 полей)
    pos_phase: float = 0.0
    neg_phase: float = 0.0
    bitrate_bps: float = 0.0
    # ... остальные метрики
```

### **Процесс обработки CF32:**
```python
def process_cf32_file(file_path):
    # 1. Загрузка
    iq_data = np.fromfile(file_path, dtype=np.complex64)

    # 2. Детекция импульса
    iq_seg = _find_pulse_segment(iq_data, ...)

    # 3. Фазовая обработка
    pulse_result = process_psk_impulse(iq_seg, ...)

    # 4. Демодуляция
    msg_hex, phase_res, edges = phase_demod_psk_msg_safe(...)

    return {
        "success": True,
        "phase_data": pulse_result["phase_rad"],
        "xs_fm_ms": pulse_result["xs_ms"],
        "msg_hex": msg_hex,
        # ... остальные метрики
    }
```

**Вывод:** Основной объем данных составляют массивы phase_data и xs_fm_ms (фазовые данные и временная ось для графика). После оптимизации размер API ответа уменьшен с 5.2 МБ до ~500 КБ.

---
*Документация создана 23.09.2025*
*Версия beacon_tester_web.py: 2.0*